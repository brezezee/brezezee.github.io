<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="../../../../../../lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="../../../../../../lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="../../../../../../css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="../../../../../../images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="../../../../../../images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="../../../../../../images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="../../../../../../images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="线性DP最长公共子序列给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的">
<meta name="keywords" content="ml,dl,cv,ai">
<meta property="og:type" content="article">
<meta property="og:title" content="brezezee">
<meta property="og:url" content="https://brezezee.github.io/2020/09/10/algorithm/Leetcode/动态规划/index.html">
<meta property="og:site_name" content="brezezee">
<meta property="og:description" content="线性DP最长公共子序列给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2021-03-31T07:18:49.193Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="brezezee">
<meta name="twitter:description" content="线性DP最长公共子序列给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://brezezee.github.io/2020/09/10/algorithm/Leetcode/动态规划/">





  <title> | brezezee</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">brezezee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="https://brezezee.github.io" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="https://brezezee.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="https://brezezee.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-categories"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="https://brezezee.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="https://brezezee.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://brezezee.github.io">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brezezee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../../../../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brezezee">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-10T14:02:08+08:00">
                2020-09-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-03-31T15:18:49+08:00">
                2021-03-31
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/10/algorithm/Leetcode/动态规划/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  7.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h3><h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = size(text1), n = size(text2);</span><br><span class="line">    <span class="keyword">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) </span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] =  max(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h4><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<ul>
<li>DP</li>
</ul>
<p>对每个位置，它的最短路径可以通过上一层与它相邻的两个节点的最短路径加上它自身的长度得到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = size(triangle);</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[m+<span class="number">1</span>], _min = <span class="number">1e9</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++ i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span> ; -- j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) dp[j] = dp[j] + triangle[i][j];</span><br><span class="line">            <span class="comment">//else if (j == i) dp[j] = dp[j-1] + triangle[i][j];</span></span><br><span class="line">            <span class="keyword">else</span> dp[j] = min(dp[j], dp[j - <span class="number">1</span>]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) </span><br><span class="line">        <span class="keyword">if</span> (_min &gt; dp[i]) _min = dp[i];</span><br><span class="line">    <span class="keyword">return</span> _min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<p>因为要求的是连续的，因此每次求最大和的时候，只需要与左边位置的最大和相加即可。那么只要左边的最大和是小于0的，就不用于左边部分保持连续了。每次只计算左边一个位置，因此只需要一个变量来保存当前位置左边的最大和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size(nums);</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>, _max = -INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; i : nums) &#123;</span><br><span class="line">        f = max(f + i, i);</span><br><span class="line">        _max = max(_max, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长公共子序列-1"><a href="#最长公共子序列-1" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">        f[i][j] = max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[m][n];</span><br></pre></td></tr></table></figure>
<h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><ul>
<li>普通DP</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])                     <span class="comment">// 遍历i之前小于a(i)的f(j)，若f(j)+1大于f(i)，则更新</span></span><br><span class="line">                f[i] = max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = max(res, f[i]);</span><br></pre></td></tr></table></figure>
<ul>
<li>贪心 + 二分</li>
</ul>
<p>，维护每个子序列的结尾的最小数值，这样后面的数如果小于它则新的子序列长度不会超过它，如果大于它则长度一定大于它，因此这个序列具有单调性。则可以通过二分来更新这个序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size(nums);</span><br><span class="line">    <span class="keyword">int</span> f[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">-1e9</span>; </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="comment">// 遍历整个序列</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 在f中找比当前数小的最大的数</span></span><br><span class="line">            <span class="keyword">if</span> (f[mid] &lt; nums[i]) l = mid ;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[l + <span class="number">1</span>] = nums[i];<span class="comment">// 该数的后面即当前数的插入位置</span></span><br><span class="line">        len = max(len, l + <span class="number">1</span>);  <span class="comment">// 保存最远位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="鸡蛋掉落"><a href="#鸡蛋掉落" class="headerlink" title="鸡蛋掉落"></a>鸡蛋掉落</h4><ul>
<li>动态规划</li>
</ul>
<p>首先明确当只有一个鸡蛋时只能挨个挨个试，而鸡蛋充足时最快的方式是直接二分查找。现在可能出现的情况是鸡蛋不足，如何利用有限的步数保证能遍历所有情况。具体的任务就是如何确定每一步鸡蛋扔的楼层。鸡蛋扔出去无非两种情况，碎或者不碎。碎了的话就往下找，此时楼层为扔时楼层的下面部分，鸡蛋损失1个。不碎的话楼层为扔时楼层的上面部分，鸡蛋无损失。然后去这两个子问题中继续求解，因为最终步数由两个子问题中较大的决定，同时目标是最小化步数，于是得到状态转移方程：</p>
<script type="math/tex; mode=display">
f(N,K) = \underset {1\le i \le N} {min}\;\;(\;max\;\;(f(i -1, K -1),\; f(N-i, K)))</script><p>这是一个关于楼层数和鸡蛋数的二维DP，并且求解一个状态转移的时候需要枚举当前可能的所有楼层，找到使得两问题中最大问题最小的楼层。因此直接计算的话复杂度是$O(N^2K)$ ，下面的代码会超时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">int</span> f[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++ i) f[i][<span class="number">1</span>] = i;   <span class="comment">//初始化，只有一个鸡蛋时只能逐层往上试</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; ++ k) &#123;</span><br><span class="line">            f[i][k] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j) &#123;</span><br><span class="line">                f[i][k] = min(f[i][k], max(f[j - <span class="number">1</span>][k - <span class="number">1</span>], f[i - j][k]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[N][K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>动态规划+二分</li>
</ul>
<p>再观察这两个子问题，发现它们随着选定的楼层一个单增一个单减，是一个此消彼长的变化。于是它们的最大值的最小点会在交点处取得，根据这个性质可以用二分来快速找到这个点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">int</span> f[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++ i) f[i][<span class="number">1</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; ++ k) &#123;</span><br><span class="line">            f[i][k] = INT_MAX;</span><br><span class="line">            <span class="comment">// for (int j = 1; j &lt;= i; ++ j) &#123;</span></span><br><span class="line">            <span class="comment">//     f[i][k] = min(f[i][k], max(f[j - 1][k - 1], f[i - j][k]) + 1);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">1</span>, r = i;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (f[mid - <span class="number">1</span>][k - <span class="number">1</span>] &gt;= f[i - mid][k]) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][k] = min (f[i][k], max(f[l - <span class="number">1</span>][k - <span class="number">1</span>], f[i - l][k]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[N][K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>动规（逆向）</li>
</ul>
<p>上面的思路是给定楼层和鸡蛋，然后在楼层区间搜索一个使得分割后的楼层的遍历步数总体最小的楼层位置，这样每次状态更新都需要在所有楼层中查找。如果不管需要验证的楼层有多少，也不管鸡蛋有多少，直接在当前层扔出鸡蛋，也会两个结果，鸡蛋碎或不碎。重新定义转移状态为$f(i, k)$表示在有$k$个鸡蛋的情况下，使用$i$ 步能确定的最大楼层。如果鸡蛋碎了，那么当前能够确认的层数是当前层 + 上一步用$k-1$个鸡蛋能确认的楼层数，即：$1 + f(i - 1, k - 1)$ ，同时还有鸡蛋未碎的情况，因此还得加上上一步用$k$个鸡蛋能确认的楼层数：$f(i-1, k)$ 。于是得到了关于步数和楼层的状态转移方程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> f[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++ i) f[<span class="number">1</span>][i] = <span class="number">1</span>;  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++ i) &#123;      <span class="comment">// 枚举可能的步数（最多N步）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++ j) &#123;  <span class="comment">// 每步可能拥有的鸡蛋数（都没碎时拥有最多的数量）</span></span><br><span class="line">            f[i][j] = <span class="number">1</span> + f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f[i][K] &gt;= N) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化一维</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> f[K + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++ i) f[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = K; j &gt;= <span class="number">1</span>; -- j) &#123;</span><br><span class="line">            f[j] = <span class="number">1</span> + f[j] + f[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f[K] &gt;= N) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="俄罗斯套娃信封"><a href="#俄罗斯套娃信封" class="headerlink" title="俄罗斯套娃信封"></a>俄罗斯套娃信封</h4><p>这个问题就是将最长上升子序列从一维扩展到了二维，可对其中一维进行排序后使用LIS，但这里不允许相同的长度套娃，因此在排序时，需要将重复的数的另一维逆序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size(ev); <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> comp = [] (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? a[<span class="number">1</span>] &gt; b[<span class="number">1</span>] : a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];  <span class="comment">// 小于为升序，大于为逆序</span></span><br><span class="line">    &#125;;</span><br><span class="line">    sort(ev.begin(), ev.end(), comp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LIS 最长上升子序列</span></span><br><span class="line">    <span class="keyword">int</span> f[n + <span class="number">1</span>], max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : ev) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = max_len;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;            <span class="comment">// 查找小于当前数的最大值（左半区间右端）</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (f[mid] &lt; c[<span class="number">1</span>]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//auto l = lower_bound(f, f + max_len, c[1]) - f;</span></span><br><span class="line">        f[l+<span class="number">1</span>] = c[<span class="number">1</span>];</span><br><span class="line">        max_len = max(max_len, <span class="keyword">int</span>(l+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h4><p>不能偷相邻的，按理说相邻涉及到左相邻和右相邻，但是在最右端是没有右邻居的。考虑将每段序列看作一个子问题，那么只需计算最右端的最大盗窃数量即可，状态转移方程为</p>
<script type="math/tex; mode=display">
dp(n) = max(dp(n - 1), dp(n - 2) + a(n))</script><p>每个状态只与之前的两个状态相关，因此可用两个变量来保存，将一维DP优化到$O(1)$空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size(a);</span><br><span class="line">    <span class="comment">// 每次更新只需要前两个变量和序列a</span></span><br><span class="line">    <span class="keyword">int</span> tmp, last = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        tmp = now; <span class="comment">// 保存当前，作为下次迭代的last</span></span><br><span class="line">        now = max(last + a[i], now);</span><br><span class="line">        last = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打家劫舍-2"><a href="#打家劫舍-2" class="headerlink" title="打家劫舍 2"></a>打家劫舍 2</h4><p>2在之前1的条件下将左端与右端连了起来，这样便不能再用端点的特殊情况，即任何点都需要判断左邻居和右邻居。但是对于左端点和右端点，发现它俩只能同时取一个，那么可按端点分两种情况出来($[0,\;n-1],\;[1,\;n]$)，只要去掉了端点，这个问题便退化成了1问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp, last = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res, n = size(nums);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];  <span class="comment">// 因为会去掉一个点，特判一下</span></span><br><span class="line">    <span class="keyword">auto</span> fun = [&amp;] (<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">        last = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++ i) &#123;</span><br><span class="line">            tmp = now;</span><br><span class="line">            now = max(now, last + nums[i]);</span><br><span class="line">            last = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;;</span><br><span class="line">    res = max(fun(<span class="number">0</span>, n - <span class="number">1</span>), fun(<span class="number">1</span>, n));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打家劫舍-3"><a href="#打家劫舍-3" class="headerlink" title="打家劫舍 3"></a>打家劫舍 3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dp</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> select;</span><br><span class="line">    <span class="keyword">int</span> notSel;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">dp <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> dp&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    dp left = helper(root-&gt;left);</span><br><span class="line">    dp right = helper(root-&gt;right);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">int</span> sel = root-&gt;val + left.notSel + right.notSel;   <span class="comment">// 选择当前根，则子节点不能选</span></span><br><span class="line">    <span class="keyword">int</span> nse = max(left.select, left.notSel) + max(right.select, right.notSel); <span class="comment">// 不选当前根，子节点不一定会选，选最大的情况</span></span><br><span class="line">    <span class="keyword">return</span> dp&#123;sel, nse&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> res = helper(root);</span><br><span class="line">    <span class="keyword">return</span> max(res.select, res.notSel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="股票系列"><a href="#股票系列" class="headerlink" title="股票系列"></a>股票系列</h3><h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h4><blockquote>
<p>只能交易一次</p>
</blockquote>
<p>此时遍历时维护之前最小的即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min_ = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : prices) &#123;</span><br><span class="line">        res = max(res, x - min_);</span><br><span class="line">        min_ = min(min_, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="买卖股票的最佳时机-2"><a href="#买卖股票的最佳时机-2" class="headerlink" title="买卖股票的最佳时机 2"></a>买卖股票的最佳时机 2</h4><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（<strong>多次交易</strong>）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p>这个题有较多做法，因为可以买入/卖出无限多次，那么只要是收益为正的交易都可以计算。</p>
<ol>
<li>遍历序列，相邻股价之差只要是正的便加上。</li>
<li>搜索所有的波谷波峰，将它们的差值加上。</li>
<li>动态规划</li>
</ol>
<p>对于动态规划，除了第i天的股价外，还需要确定当天是持有股票还是未持有，这样才能判断是买入还是卖出。设$dp(i, 0),\;dp(i, 1)$分别表示第$i$天未持股和持股，则可以写出它们的转移方程为：</p>
<script type="math/tex; mode=display">
dp(i, 0) = max\left ( dp(i-1, 0),\;\; dp(i-1, 1) + prices[i] \right)\\
dp(i, 1) = max\left ( dp(i-1, 1),\;\; dp(i-1, 0) - prices[i] \right)</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>其中第二维实际只有两个变量，并且枚举的过程中只用到了相邻前一天的结果，因此可用两个变量来代替二维数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stock = - prices[<span class="number">0</span>], cash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">    <span class="comment">// 如果cash更新为stock + prices[i] ，带入二式，它并不会影响下一个式子更新</span></span><br><span class="line">    cash = max(cash, stock + prices[i]);</span><br><span class="line">    stock = max(stock, cash - prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cash;</span><br></pre></td></tr></table></figure>
<p>按理说更新第一个式子前应该将它之前的数值保存的，因为下个式子的更新会用到。但是观察它更新后的结果，即使cash更新产生了变化，将变化带入二式它不会影响最终结果。</p>
<h4 id="买卖股票的最佳时机-3"><a href="#买卖股票的最佳时机-3" class="headerlink" title="买卖股票的最佳时机 3"></a>买卖股票的最佳时机 3</h4><blockquote>
<p>与上一题想比，这题限制最多只能交易两次。这就需要求出最高和次高收益 的交易，这样之前两个类似贪心的方法就不能用了。</p>
</blockquote>
<p>本题增加了一个限制：交易次数。直接用之前的思路可以添加一维状态，用来表示第几次交易：比如$dp(i, k, 0)$表示第i天时处于第K 次交易的未持有状态（即还未买入），1表示第k次交易已持股状态。则对于某一天的第k次交易，其状态转移与上一题是一样的：</p>
<script type="math/tex; mode=display">
dp(i, k, 0) = max(dp(i, k, 0) , dp(i, k - 1, 1) + prices[i]) \\
dp(i, k, 1) = max(dp(i, k, 1) , dp(i, k, 0) - prices[i])</script><p>即当前未持股可以从之前就未持股或之前持股但是卖出 而转移过来，当前持股可以从之前就持股或之前未持股但是买入而转移过来。这里因为k比较小，只有2，所以可以不用循环，直接展开。后面的问题当k大于2时其实就是同样的方法扩展而已。</p>
<p>初始化： 这里需要将第一天进行第几次买入都初始化为 - prices[0]，不然在计算时会取到没花钱的0作为买入状态。</p>
<pre><code>int maxProfit(vector&lt;int&gt;&amp; prices) {
    int n = size(prices);
    if (n &lt; 2) return 0;
    int dp[n][3][2];
    memset(dp, 0, sizeof dp);
    dp[0][0][1] = - prices[0]; // 
    dp[0][1][1] = - prices[0];
    for (int i = 1; i &lt; n; ++ i) {
        dp[i][0][1] = max(dp[i-1][0][1], dp[i-1][0][0] - prices[i]); // 第一次买入
        dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][0][1] + prices[i]); // 第一次出售
        dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][1][0] - prices[i]); // 第二次买入
        dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][1][1] + prices[i]); // 第二次出售
    }
    return dp[n-1][2][0];
}
</code></pre><p>​     </p>
<p>显然这个DP同之前一样可以优化，每个状态都只用到前一天的，因此不需要保存所有天数的状态。这里k为2，买入卖出占2个状态，实际也只需要4个变量就能表示，但是用一个3x2数组也无所谓。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size(prices);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>];<span class="comment">// </span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = max(dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">0</span>] - prices[i]); </span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = max(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] + prices[i]); <span class="comment">// </span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = max(dp[<span class="number">1</span>][<span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">0</span>] - prices[i]); <span class="comment">// </span></span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">0</span>] = max(dp[<span class="number">2</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>] + prices[i]); <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题还有个特殊的方法，因为k=2，所以这题相当于求最高和次高的收益。他俩一定是不重合的，因此可以通过顺序扫描和逆序扫描两次遍历来找出两个较高收益。因为不重合，所以用扫描经过的点将前段最高收益和后段最高收益区分开。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="keyword">int</span> f[n + <span class="number">1</span>], res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从左往右，记录当前位置之前进行的交易能得的最大利润</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, minv = INT_MAX; i &lt;= n; ++ i) &#123;</span><br><span class="line">        f[i] = max(f[i - <span class="number">1</span>], prices[i - <span class="number">1</span>] - minv);  <span class="comment">// 0 ~ i - 1段的最大收益</span></span><br><span class="line">        minv = min(minv, prices[i - <span class="number">1</span>]);   <span class="comment">// minv表示之前股价的最小点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从右往左，计算从当前位置到结束位置进行的交易能得的最大利润</span></span><br><span class="line">    <span class="keyword">int</span> max_profit = <span class="number">0</span>, maxv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i ; -- i) &#123;</span><br><span class="line">        max_profit = (max_profit, maxv - prices[i - <span class="number">1</span>]);</span><br><span class="line">        maxv = max(maxv, prices[i - <span class="number">1</span>]);</span><br><span class="line">        res = max(res, f[i - <span class="number">1</span>] + max_profit );  <span class="comment">// 前面段的最大收益和 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="买卖股票的最佳时机-4"><a href="#买卖股票的最佳时机-4" class="headerlink" title="买卖股票的最佳时机 4"></a>买卖股票的最佳时机 4</h4><p>与之前类似，将变化的k纳入循环之中即可，由于k可能很大，这时问题实际已退化到可以交易任意次的情况，因此在前面加入判别即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size(prices);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当k较大时，问题退化为可以交易任意次</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt; (n &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>, buy = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            sell = max(sell, buy + prices[i]);</span><br><span class="line">            buy = max(buy, sell - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[k+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) dp[i][<span class="number">1</span>] = - prices[<span class="number">0</span>];   <span class="comment">// 初始化第一天第k次买入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++ j)&#123;</span><br><span class="line">            dp[j][<span class="number">0</span>]   = max(dp[j][<span class="number">0</span>],   dp[j<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);  <span class="comment">// 未持 &lt;= 之前未持股 或 上次交易持股并卖出</span></span><br><span class="line">            dp[j<span class="number">-1</span>][<span class="number">1</span>] = max(dp[j<span class="number">-1</span>][<span class="number">1</span>], dp[j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);  <span class="comment">// 持股 &lt;= 之前已持股 或 上次交易未持并买入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="买卖股票含冷冻期"><a href="#买卖股票含冷冻期" class="headerlink" title="买卖股票含冷冻期"></a>买卖股票含冷冻期</h4><p>距离上次交易需要有一天冷冻期，即卖出后不能立马买。相当于依赖的状态需要用到前两天，只需稍微改动即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dp[n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="买卖股票含手续费"><a href="#买卖股票含手续费" class="headerlink" title="买卖股票含手续费"></a>买卖股票含手续费</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> buy = - prices[<span class="number">0</span>], sell = <span class="number">0</span>;   <span class="comment">// 状态： 持有、未持有</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        buy = max(buy, sell - prices[i]);</span><br><span class="line">        sell = max(sell, buy + prices[i] - fee);  <span class="comment">// 卖出时完成这笔交易，支付手续费</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="秋叶收藏集"><a href="#秋叶收藏集" class="headerlink" title="秋叶收藏集"></a>秋叶收藏集</h4><blockquote>
<p>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。<br>出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。</p>
<p>输入：leaves = “rrryyyrryyyrr”<br>输出：2<br>解释：调整两次，将中间的两片红叶替换成黄叶，得到 “rrryyyyyyyyrr”</p>
</blockquote>
<p>题意就是需要将序列分为三个区间，使得所有区间不合条件的叶子最少，比如左区间需要黄叶最少，中区间需要红叶最少，且需要它们总体最少。</p>
<h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><ul>
<li>关键点</li>
</ul>
<blockquote>
<p>有三种操作，那么两个字符串在求解到子问题 i， j位置时，它们的上一个状态可以从三种情况转移过来，同时如果当前字符相等的话，就可以节省一次操作。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = size(a), n = size(b);</span><br><span class="line">    <span class="keyword">int</span> dp[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) dp[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            <span class="comment">// 初始为之前的三种状态 + 1</span></span><br><span class="line">            dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果相等的话可以少一次操作</span></span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) dp[i][j] = min(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = size(a), n = size(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) f[i] = i; <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre = i - <span class="number">1</span>; <span class="comment">// 保存上一层的的状态f[i - 1][j - 1],每进入下一层循环j变为0，实际上=f[i-1][0]</span></span><br><span class="line">        f[<span class="number">0</span>] = i;        <span class="comment">// 等价于最开始的初始化f[i][0] = i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = f[j];<span class="comment">// 刚进入得到的状态是上一层的，保存还未更改的状态</span></span><br><span class="line">            <span class="keyword">if</span> (a[i<span class="number">-1</span>] == b[j<span class="number">-1</span>]) f[j] = pre;</span><br><span class="line">            <span class="keyword">else</span> f[j] = min(f[j], min(f[j<span class="number">-1</span>], pre)) + <span class="number">1</span>;</span><br><span class="line">            pre = tmp;     <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h4><blockquote>
<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。</p>
</blockquote>
<p>​        问号可以匹配单个字符，那么直接将其看作一个万能字符即可，而星号可匹配任意字符串，包括空串，也就是星号可以匹配0次，1次和多次。先设出状态，令$f(i, j)$表示字符串$s$的$i$之前的子串和字符串$p$的$j$之前的子串是否匹配。那么遇到星号的状态转移为：</p>
<script type="math/tex; mode=display">
f(i, j) = f(i, j - 1) \;|\;f(i-1, j-1)\;|\;f(i-1,j)</script><p>分别是表示匹配0次，1次和多次的情况，然而匹配1次和多次的情况是可以合并的，都用多次来表示，这样状态表示为：</p>
<script type="math/tex; mode=display">
f(i,j) = f(i, j - 1) \; |\;f(i - 1, j)</script><p>这个转移方程也可以解释为是否使用星号。</p>
<p>初始化：</p>
<p>​        当字符串都为空时是匹配的，因此f(0, 0) 应该是匹配的，并且当s为空，p全为*时也是匹配的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// s = ' ' + s;</span></span><br><span class="line">    <span class="comment">// p = ' ' + p;</span></span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> f[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;   <span class="comment">// 对应p串开始全是*的情况</span></span><br><span class="line">        <span class="keyword">if</span> (p[i - <span class="number">1</span>] == <span class="string">'*'</span>) f[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span>)&#123;  <span class="comment">// 可以匹配一个/ 匹配多个 / 匹配0个</span></span><br><span class="line">                f[i][j] |=  f[i - <span class="number">1</span>][j] | f[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'?'</span> || p[j - <span class="number">1</span>] == s[i - <span class="number">1</span>])&#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">// 只能匹配当前一个字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h4><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<blockquote>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素</p>
</blockquote>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<ul>
<li>动态规划思路</li>
</ul>
<p>&emsp;&emsp;先从爆搜的思路看这个问题，对于字符串p，因为<code>*</code>的存在，它是可变长的。如果在搜索过程中贪心的让它匹配当前能匹配的最长串，就可能错过回溯能正确匹配的串。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">a*a</span><br></pre></td></tr></table></figure>
<p>那么对于当前长度的s，可能p有多个能与它匹配的方案，为了在枚举这些方案的时候减少重复计算，就可以使用动态规划的思想，保存之前能够成功匹配的方案。</p>
<p>状态定义： $dp(i, j)$ 表示$s$的$[0, \;i]$范围子串和$p$的$[0, \; j]$范围子串是否能够匹配。</p>
<p>在已知$dp(i - 1, j - 1)$和$s[i], p[j]$的情况，可以根据$s[i] == p[j]$得到$dp(i, j) = dp(i-1,j-1)$。</p>
<p><code>.</code>表示任意单个字符，因此它可以纳入普通的比较单个字符是否相等的情况。</p>
<p><code>*</code>则可以复制任意次其前面的字符，其中对应关系为：</p>
<p>0次：$dp(i, j - 2)$</p>
<p>1次：$dp(i-1, j - 2)$</p>
<p>…</p>
<p>n次:  $dp(i-n, j -2)$</p>
<p>这样罗列情况太多了，当复制多次(大于等于1)时，可以看作当前<code>*</code>保留，而s串删除末尾一个，这样它将是相同情况，后面再访问到还可以执行同样的操作。得到</p>
<p>$dp(i - 1, j)$ </p>
<p>整理得到转移方程：</p>
<script type="math/tex; mode=display">
dp(i, j) =\begin{cases}
 dp(i-1, j -1)& \text{ if }  (p[j]\neq'*'\; \& \;(s[i]=p[j] \;|\;p[j] = '.') \\ 
 \begin{cases}
 dp(i, j - 2) | dp(i,j-1)|dp(i-1,j)& \text{ if } ( s[i] = p[j]) \\
 dp(i, j - 2) & \text{if} (s[i] \neq p[j]) 
 \end{cases}  & \text {if} (p[j] = '*')


\end{cases}</script><ul>
<li>代码细节</li>
</ul>
<ol>
<li>当两个串都是空串时应该是匹配的，并且当s是空串，p是形如”a*”这样的串应该也是匹配的，它需要初始化$dp(0, 0) = true$。那么$dp(0, 0)$便不能用来表示第一个字符是否匹配，为了方便，在s和p前添加一个空格来适配这种情况。这样如果是空串的话，添加空格后，$dp(1, 1)$表示空串的状    态·。</li>
<li>还须注意的是字符串下标从$0$开始，因此在判断$dp(i, j)$时，它们实际对应的字符是$s[i-1]$和$p[j - 1]$.</li>
<li>在$p[j] = ‘*’$的情况下，复制一次和复制多次的情况是可以合并的，可统一表示为$dp(i-1, j)$。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    s = <span class="string">' '</span> + s;</span><br><span class="line">    p = <span class="string">' '</span> + p;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> match = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j] == <span class="string">'.'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> s[i] == p[j];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;   </span><br><span class="line">                <span class="keyword">if</span> (match(i - <span class="number">1</span>, j - <span class="number">2</span>)) &#123;  <span class="comment">// 遇到*时，去跟它前面的数匹配</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i][j - <span class="number">2</span>]; <span class="comment">// 状态转移： * 可用于继续匹配i - 1， 或者*为0次，此时将j-1消去，按i 与 j-2是否匹配转移</span></span><br><span class="line">                    <span class="comment">// 例如 s = aa , p = b*aa  该式结果为匹配 </span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>];   <span class="comment">// i和j-1不匹配，只能去匹配j-2了 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (match(i - <span class="number">1</span>, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; dp[i][j] &lt;&lt; ' ';</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size(), max_len = <span class="number">1</span>, start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> f[n+<span class="number">5</span>][n+<span class="number">5</span>]; </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) f[i][i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举所有区间，只需要判断是否是回文串即可</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n;  ++ j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - i &lt; <span class="number">2</span>) f[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> f[i][j] = f[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(f[i][j])&#123;</span><br><span class="line">                <span class="keyword">if</span> (max_len &lt; j - i + <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    max_len = j - i + <span class="number">1</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substr(start, max_len);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size(s);</span><br><span class="line">    <span class="keyword">int</span> f[n][n];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) f[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于dp公式中需要dp(i + 1, j) , dp(i, j - 1)。因此枚举时需要保证这两个已经更新过，即区间内的点都更新过</span></span><br><span class="line">    <span class="comment">// 可以从递增的枚举右区间，内层递减的枚举左区间，这样左右边界都是更新过的。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j) &#123;   <span class="comment">// 记忆化搜索，</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) f[i][j] = f[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = max(f[i + <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两端DP"><a href="#两端DP" class="headerlink" title="两端DP"></a>两端DP</h3><h4 id="执行乘法运算的最大分数"><a href="#执行乘法运算的最大分数" class="headerlink" title="执行乘法运算的最大分数"></a>执行乘法运算的最大分数</h4><blockquote>
<p>给你两个长度分别 <code>n</code> 和 <code>m</code> 的整数数组 <code>nums</code> 和 <code>multipliers</code> ，其中 <code>n &gt;= m</code> ，数组下标 <strong>从 1 开始</strong> 计数。</p>
<p>初始时，你的分数为 <code>0</code> 。你需要执行恰好 <code>m</code> 步操作。在第 <code>i</code> 步操作（<strong>从 1 开始</strong> 计数）中，需要：</p>
<ul>
<li>选择数组 <code>nums</code> <strong>开头处或者末尾处</strong> 的整数 <code>x</code> 。</li>
<li>你获得 <code>multipliers[i] * x</code> 分，并累加到你的分数中。</li>
<li>将 <code>x</code> 从数组 <code>nums</code> 中移除。</li>
</ul>
<p>在执行 <code>m</code> 步操作后，返回 <strong>最大</strong> 分数<em>。</em></p>
</blockquote>
<p>题意就是需要在nums中依次为multipliers中的数找到一个数与它相乘，使得所有乘积的和最大。并且只能在nums的两端寻找，nums中的数只能用一次。</p>
<p>因为用过的数不能再用，所以不能贪心。具体点就是需要在nums中找m次，每次有两种不同的选择。将状态设置为左边取走l个数，右边取走r个数的和。观察选择后的结果，是取走左边或右边的一个数，这个状态可从前一个状态转移过来。并且与上一个状态之前的状态（左右分别是第几次取走的）无关。</p>
<p>因此只需要枚举左右取的数量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; mp)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.size(), m = mp.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">-1e9</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 左右都未取时为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; m; ++ l) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r + l &lt; m; ++ r) &#123;</span><br><span class="line">            dp[l + <span class="number">1</span>][r] = max(dp[l + <span class="number">1</span>][r], dp[l][r] + mp[l + r] * nums[l]);</span><br><span class="line">            dp[l][r + <span class="number">1</span>] = max(dp[l][r + <span class="number">1</span>], dp[l][r] + mp[l + r] * nums[n - <span class="number">1</span> - r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        res = max(res, dp[i][m - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="../../../../09/TiMi/platform/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="../../../../11/algorithm/Acwing/字符串/" rel="prev" title>
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">brezezee</p>
              <p class="site-description motion-element" itemprop="description">靡不有初，鲜克有终</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="https://brezezee.github.io/archives">
              
                  <span class="site-state-item-count">139</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="../../../../../../categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="../../../../../../tags/index.html">
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#线性DP"><span class="nav-text">线性DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最长公共子序列"><span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三角形最小路径和"><span class="nav-text">三角形最小路径和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最大子序和"><span class="nav-text">最大子序和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最长公共子序列-1"><span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最长上升子序列"><span class="nav-text">最长上升子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#鸡蛋掉落"><span class="nav-text">鸡蛋掉落</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#俄罗斯套娃信封"><span class="nav-text">俄罗斯套娃信封</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打家劫舍"><span class="nav-text">打家劫舍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打家劫舍-2"><span class="nav-text">打家劫舍 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打家劫舍-3"><span class="nav-text">打家劫舍 3</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#股票系列"><span class="nav-text">股票系列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#买卖股票的最佳时机"><span class="nav-text">买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#买卖股票的最佳时机-2"><span class="nav-text">买卖股票的最佳时机 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#买卖股票的最佳时机-3"><span class="nav-text">买卖股票的最佳时机 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#买卖股票的最佳时机-4"><span class="nav-text">买卖股票的最佳时机 4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#买卖股票含冷冻期"><span class="nav-text">买卖股票含冷冻期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#买卖股票含手续费"><span class="nav-text">买卖股票含手续费</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#秋叶收藏集"><span class="nav-text">秋叶收藏集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串匹配"><span class="nav-text">字符串匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编辑距离"><span class="nav-text">编辑距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通配符匹配"><span class="nav-text">通配符匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#正则表达式匹配"><span class="nav-text">正则表达式匹配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区间DP"><span class="nav-text">区间DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最长回文子串"><span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最长回文子序列"><span class="nav-text">最长回文子序列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两端DP"><span class="nav-text">两端DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#执行乘法运算的最大分数"><span class="nav-text">执行乘法运算的最大分数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">brezezee</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">180.7k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="../../../../../../lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="../../../../../../lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="../../../../../../lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="../../../../../../lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../../../../../lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../../../../../lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="../../../../../../js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="../../../../../../js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="../../../../../../js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="../../../../../../js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="../../../../../../js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://brezezee.github.io/2020/09/10/algorithm/Leetcode/动态规划/';
          this.page.identifier = '2020/09/10/algorithm/Leetcode/动态规划/';
          this.page.title = '';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
