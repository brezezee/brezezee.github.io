<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="../../../../../lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="../../../../../lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="../../../../../css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="../../../../../images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="../../../../../images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="../../../../../images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="../../../../../images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="刷题,剑指offer,">










<meta name="description" content="1. 二维数组(vector)查找 题目描述  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 法一： 左下/右上查找 &amp;emsp;&amp;emsp;该题给出的数组单看行或者列都是单增的，但是中间某点只能确定其左上的区域是小于它的，并不能确定在其余三个区域中的">
<meta name="keywords" content="刷题,剑指offer">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer">
<meta property="og:url" content="https://brezezee.github.io/2019/08/23/剑指offer/剑指offer/index.html">
<meta property="og:site_name" content="brezezee">
<meta property="og:description" content="1. 二维数组(vector)查找 题目描述  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 法一： 左下/右上查找 &amp;emsp;&amp;emsp;该题给出的数组单看行或者列都是单增的，但是中间某点只能确定其左上的区域是小于它的，并不能确定在其余三个区域中的">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://brezezee.github.io/2019/08/23/剑指offer/剑指offer/1566483039647.png">
<meta property="og:updated_time" content="2019-09-20T12:33:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer">
<meta name="twitter:description" content="1. 二维数组(vector)查找 题目描述  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 法一： 左下/右上查找 &amp;emsp;&amp;emsp;该题给出的数组单看行或者列都是单增的，但是中间某点只能确定其左上的区域是小于它的，并不能确定在其余三个区域中的">
<meta name="twitter:image" content="https://brezezee.github.io/2019/08/23/剑指offer/剑指offer/1566483039647.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://brezezee.github.io/2019/08/23/剑指offer/剑指offer/">





  <title>剑指offer | brezezee</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">brezezee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="https://brezezee.github.io" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="https://brezezee.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="https://brezezee.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-categories"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="https://brezezee.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="https://brezezee.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://brezezee.github.io">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brezezee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../../../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brezezee">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">剑指offer</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:00+08:00">
                2019-08-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2019-09-20T20:33:01+08:00">
                2019-09-20
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="../../../../../categories/code-practice/" itemprop="url" rel="index">
                    <span itemprop="name">刷题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/23/剑指offer/剑指offer/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  7.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="1-二维数组-vector-查找"><a href="#1-二维数组-vector-查找" class="headerlink" title="1. 二维数组(vector)查找"></a>1. 二维数组(vector)查找</h3><ul>
<li><strong>题目描述</strong></li>
</ul>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>法一：</strong> 左下/右上查找</p>
<p>&emsp;&emsp;该题给出的数组单看行或者列都是单增的，但是中间某点只能确定其左上的区域是小于它的，并不能确定在其余三个区域中的哪一个。因为按从最左上开始寻找是不容易找到较好的方法的，于是可从左下角或者右上角开始寻找，这两个位置可以看作一个特殊的<strong>“中点”</strong>，它将它所在的行和列正好分割。它所在的行都大于它，所在的列都小于它。如此当target小于它时，按列查找，大于它时，按行查找。复杂度$O(n+m)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size_i=<span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> size_j=<span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(size_i==<span class="number">0</span> || size_j==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//判断空数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> i = size_i<span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &gt;= <span class="number">0</span> &amp;&amp; j &lt; size_j )&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; <span class="built_in">array</span>[i][j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; <span class="built_in">array</span>[i][j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>法二：</strong> 旋转折半查找</p>
<p>&emsp;&emsp; 这种形式的数据还有一个规律，以边界上的点作切割，其右边部分都是大于它的，因为按行按列单增。那么可以在四个边界上查找，依次旋转，每次进行的折半查找都能排除掉其右边的切割部分。不断进行直到最后区域只剩一个点为止。</p>
<p><img src="1566483039647.png" alt="1566483039647"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">array</span>.size()==<span class="number">0</span> || <span class="built_in">array</span>[<span class="number">0</span>].size()==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">int</span> top = <span class="number">0</span>, bottom = <span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">           <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">array</span>[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">           <span class="keyword">int</span> sLeft = <span class="number">0</span>, sRight = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> sTop = <span class="number">0</span>, sBottom = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (;left&lt;right || top&lt;bottom;) &#123;</span><br><span class="line">               <span class="comment">//对上边界进行折半，可以缩小右边界</span></span><br><span class="line">               sLeft = left, sRight = right;</span><br><span class="line">               <span class="keyword">for</span> (;sLeft&lt;=sRight;) &#123;</span><br><span class="line">                   mid = (sLeft + sRight) / <span class="number">2</span>;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="built_in">array</span>[top][mid]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[top][mid]&lt;target) sLeft = mid+<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span> sRight = mid<span class="number">-1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (mid&lt;right) right = mid; <span class="comment">//利用终止点缩小右边界</span></span><br><span class="line">               top++;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//对右边界进行折半，可以缩小上边界</span></span><br><span class="line">               sTop = top, sBottom = bottom;</span><br><span class="line">               <span class="keyword">for</span> (;sTop&lt;=sBottom;) &#123;</span><br><span class="line">                   mid = (sTop + sBottom) / <span class="number">2</span>;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="built_in">array</span>[mid][right]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[mid][right]&lt;target) sTop = mid+<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span> sBottom = mid<span class="number">-1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (top&lt;mid) top = mid; <span class="comment">//利用终止点缩小上边界</span></span><br><span class="line">               right--;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//对下边界进行折半，可以缩小左边界</span></span><br><span class="line">               sLeft = left, sRight = right;</span><br><span class="line">               <span class="keyword">for</span> (;sLeft&lt;=sRight;) &#123;</span><br><span class="line">                   mid = (sLeft + sRight) / <span class="number">2</span>;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="built_in">array</span>[bottom][mid]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[bottom][mid]&lt;target) sLeft = mid+<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span> sRight = mid<span class="number">-1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (left&lt;mid) left = mid; <span class="comment">//利用终止点缩小左边界</span></span><br><span class="line">               bottom--;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//对左边界进行折半，可以缩小下边界</span></span><br><span class="line">               sTop = top, sBottom = bottom;</span><br><span class="line">               <span class="keyword">for</span> (;sTop&lt;=sBottom;) &#123;</span><br><span class="line">                   mid = (sTop + sBottom) / <span class="number">2</span>;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="built_in">array</span>[mid][left]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[mid][left]&lt;target) sTop = mid+<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span> sBottom = mid<span class="number">-1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (mid&lt;bottom) bottom = mid; <span class="comment">//利用终止点缩小下边界</span></span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">array</span>[top][left]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>法三：</strong> 十字分割</p>
<p>&emsp;&emsp;若将该数组按中间某点分为四个区域，在其主对角线上的两个区域（也就是左上和右下）是比较有特点的，左上的全部小于该点，右下的全部大于该点。那么可在其主对角线上先搜索一遍，如果没找到，就可以排除这两个区域，再对左下和右上两个区域进行如此递归。显然用折半查找比较合适。但是当该数组不是方阵的时候效率很低。</p>
<h3 id="2-字符串空格替换"><a href="#2-字符串空格替换" class="headerlink" title="2. 字符串空格替换"></a>2. 字符串空格替换</h3><ul>
<li>题目描述</li>
</ul>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>&emsp;&emsp;这个题中提供的字符串以字符数组的形式给出，需要将一个空格替换为三个字符，因此数组的长度会变。若是从前面开始直接遇到一个空格 便替换，后面剩余的字符串都需要往后移动，因此用从后往前替换的方法。从后往前则需要事先确定替换后的数组长度，因此先遍历一遍，得到空格数量。然后从尾部开始遇到空格便替换即可。下面这种在替换过程中计算下标的写法让代码较简洁一些，但是有许多乘积运算。因此考虑效率最好还是先计算出总长度，然后—即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[i + <span class="number">2</span>*count]=<span class="string">'0'</span>;</span><br><span class="line">                str[i + <span class="number">2</span>*count - <span class="number">1</span>] = <span class="string">'2'</span>;</span><br><span class="line">                str[i + <span class="number">2</span>*count - <span class="number">2</span>] = <span class="string">'%'</span>;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str[i + <span class="number">2</span>*count] = str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-链表逆序"><a href="#3-链表逆序" class="headerlink" title="3. 链表逆序"></a>3. 链表逆序</h3><ul>
<li>题目描述</li>
</ul>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<p>&emsp;&emsp;思路较多，可以递归、栈、反向迭代器、链表逆序等。</p>
<p>法一：反向迭代器(3ms，472k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res.rbegin(),res.rend());  <span class="comment">//反向迭代器创建一个临时逆序向量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法二：递归 (3ms，484k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;  <span class="comment">//递归时不能将其定义在函数内部，局部变量退出被删除</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">             printListFromTailToHead(p-&gt;next);</span><br><span class="line">          &#125;</span><br><span class="line">        res.push_back(p-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法三：栈(3ms，500k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            stk.push(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            res.push_back(stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法四：链表逆序(3ms,512k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(struct ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        ListNode *buf=head;</span><br><span class="line">        ListNode *pre=buf;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span>)&#123; <span class="comment">//head不再需要，作为过渡指针</span></span><br><span class="line">            buf=head-&gt;next;</span><br><span class="line">            head-&gt;next=buf-&gt;next;</span><br><span class="line">            buf-&gt;next=pre;            </span><br><span class="line">            pre=buf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(buf)&#123;</span><br><span class="line">            vec.push_back(buf-&gt;val);</span><br><span class="line">            buf=buf-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-重建二叉树（前，中序）"><a href="#4-重建二叉树（前，中序）" class="headerlink" title="4. 重建二叉树（前，中序）"></a>4. 重建二叉树（前，中序）</h3><ul>
<li>题目描述</li>
</ul>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>&emsp;&emsp;根据前序和中序重建二叉树，前序可确定当前序列中的根节点，根据根节点可在中序中找到根节点来分割当前根节点的左右子树。而对于在中序遍历中划分出来的左右子树的长度与先序遍历的长度一定是相同的，所以不断迭代找根节点，划分左右子树的过程便能重建该二叉树。</p>
<p>&emsp;&emsp;对于数组的划分，python有切片功能，用python实现代码相当简洁：(50ms,5321k)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(pre.pop(<span class="number">0</span>))</span><br><span class="line">        index = tin.index(root.val)</span><br><span class="line">        root.left = self.reConstructBinaryTree(pre, tin[:index]) </span><br><span class="line">        <span class="comment">#每次递归都会将pre出栈一个，因此不需要管它，它的长度变化满足左右子树</span></span><br><span class="line">        root.right = self.reConstructBinaryTree(pre, tin[index + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>C++不能直接切分，就需要手动给出每个子树的起始和终止范围。虽然写起来较python复杂一点，但效率高多了。(4ms,523k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in)</span> </span>&#123;</span><br><span class="line">        TreeNode* root=ConstructBinaryTree(pre, <span class="number">0</span>, pre.size()<span class="number">-1</span>, in, <span class="number">0</span>, in.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">ConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="keyword">int</span> startPre,<span class="keyword">int</span> endPre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in,<span class="keyword">int</span> startIn,<span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startPre&gt;endPre)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        <span class="keyword">if</span>(startPre == endPre)</span><br><span class="line">                <span class="keyword">return</span> root;      <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == pre[startPre])&#123;</span><br><span class="line">               <span class="keyword">int</span> len_of_left = i-startIn;</span><br><span class="line">               <span class="keyword">int</span> len_of_right = endIn-i;</span><br><span class="line">               root-&gt;left = ConstructBinaryTree(pre, startPre+<span class="number">1</span>, startPre+len_of_left, in, startIn, i<span class="number">-1</span>);</span><br><span class="line">               root-&gt;right = ConstructBinaryTree(pre, startPre+len_of_left+<span class="number">1</span>, endPre, in, i+<span class="number">1</span>, endIn);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-双栈队列"><a href="#5-双栈队列" class="headerlink" title="5. 双栈队列"></a>5. 双栈队列</h3><ul>
<li>题目描述</li>
</ul>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p>&emsp;&emsp;队列与栈的主要区别是出栈方向不同，那么即可以维护入栈时的顺序，可以维护出栈时的顺序。但是维护入栈顺序每次来新数据都需要将已经入栈的数据来回倒换，因此选择维护出栈顺序。出队列时，将A栈中数据倒换到B栈，从B栈中出去的数据便是正常的队列顺序。且这个过程中，已经倒换的B栈的数据不需要再倒换回去，因为它们相对于后面新入栈的数据就是“先来的”，就应当先出栈。所以pop操作先检查B栈是否有数据，有则直接pop，无则将A栈数据全部倒换到B栈。（3ms,356k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.empty() &amp;&amp;stack2.empty())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                        stack2.push(stack1.top());</span><br><span class="line">                        stack1.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h3><ul>
<li>题目描述</li>
</ul>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>&emsp;&emsp;如果是严格递增的数组，那么使用二分法的时候只有两种情况：一是mid&gt;high，这时最小数字一定在后半部分。而是mid<high，这时最小数字在前半部分。但非递减数组的话就有可能存在相等的情况，比如`1 0 1 1`和`1 1`，这时无法确定最小数字的位置在哪边。因此只能慢慢减少high或增加low来缩小范围，当然这是low="mid=high的情况，我们可以判断mid与low的大小关系来剪去一部分多余操作。若此时low<mid，那么low即是最小数字，low">mid时，最小数字可能是mid或在左边，比如<code>2 3 1 1 1</code>,<code>3 1 2 2 2</code>，令high=mid即可，但若mid=low，真的只能挨个试了。</high，这时最小数字在前半部分。但非递减数组的话就有可能存在相等的情况，比如`1></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ Solution 28ms,603k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>, high = rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rotateArray[low]&lt;rotateArray[high])</span><br><span class="line">                    <span class="keyword">return</span> rotateArray[low];  <span class="comment">//剪枝</span></span><br><span class="line">                mid  = (low + high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[high])&#123;</span><br><span class="line">                        low = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[high])&#123;</span><br><span class="line">                        high = mid ;<span class="comment">//下取整</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[low])</span><br><span class="line">                                <span class="keyword">return</span> rotateArray[low]; <span class="comment">//剪枝</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[low])</span><br><span class="line">                            	high = mid;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                high--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rotateArray[high];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;虽然理论上在mid = high的时候可以比较mid 与 low进行剪枝，但实际运行的效率好像并没有提高。可能没有人这么无聊做这种测试数据吧，哈哈。</p>
<h3 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h3><ul>
<li>题目描述</li>
</ul>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p>
<p>n&lt;=39</p>
<p>&emsp;&emsp;提到斐波那契数列想到的可能是递归，但是递归的空间复杂度和时间复杂度都比较高，有较多的重复计算，并且其调用栈会累积，若n过大一定会stack overflow的。但是这个题也不是不能用递归，对于调用栈的问题，可以使用尾递归的方式避免。尾递归可以参考这篇<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">博客</a>，简单来讲就是让递归调用函数发生在最后一步，即return，并且只能return函数，不能做运算，可以将需要的变量通过函数参数方式传递。这样干干净净的调用时系统不会保存在函数局部用过的变量内容，只需要记录1个调用位置，于是避免了堆栈溢出的风险。</p>
<p>&emsp;&emsp;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 尾递归 4ms 484k  O(n) O(n)直接递归的话632ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> fun(n, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> a2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> fun(n<span class="number">-1</span>, a2, a1+a2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种改造成尾递归的方式相当于将n当成了一个计数变量，<code>a1,a2</code>用来计算实际上的Fibonacci数列值。Fibonacci就是前两个Fibonacci数列的和，<code>a1,a2</code>保存的就是它们的值。且计算从数列的最小情况开始计算，避免了重复计算。</p>
<p>显然，这种方式可以直接改造成循环来实现，n只是一个计数变量而已。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 循环 3ms 464k  O(n) O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="number">0</span>, a2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a2 = a2 + a1;</span><br><span class="line">        a1 = a2 - a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看了别人的代码发现还有更简化的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="number">0</span>, a2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        a2 = a2 + a1;</span><br><span class="line">        a1 = a2 - a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-1-矩阵快速幂留坑"><a href="#7-1-矩阵快速幂留坑" class="headerlink" title="7.1 矩阵快速幂留坑"></a>7.1 矩阵快速幂留坑</h4><h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h3><ul>
<li>题目描述</li>
</ul>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>&emsp;&emsp;这是一个找规律的题，可以从开始和结尾两个方向进行分析。首先每次只有两种跳法，跳一步或两步。<strong>从开头来看</strong>：若第一次跳一步，那么后面就剩<code>n-1</code>阶，变成<code>n-1</code>阶的原问题。若第一次跳两步，那么后面剩<code>n-2</code>阶，变成<code>n-2</code>阶的原问题。总共就这两种情况，因此<code>n</code>阶的原问题<code>f(n)</code>可表示为<code>f(n-1)+f(n-2)</code>。这就是上一题的斐波那契数列的递推式。<strong>从结尾来看</strong>：最终结果是跳到n，那么可能出现的最后一跳的位置只可能是<code>n-1</code>和<code>n-2</code>，最后一跳的位置已确定，那么有多少种跳到<code>n-1</code>和<code>`n-2</code>的方案，就有多少种跳到<code>n</code>的方案。同样得到斐波那契数列递推式，不过从实际情况来看并不完全满足斐波那契。当<code>n=2</code>时，有两种情况。按递推式，莫不是<code>n=0</code>时 不跳也算一种方案？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 470k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">int</span> a1 = <span class="number">1</span>, a2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++)&#123;</span><br><span class="line">            a2 = a1 + a2;</span><br><span class="line">            a1 = a2 - a1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h3><ul>
<li>题目描述</li>
</ul>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>&emsp;&emsp;这就是上一个题的扩展，可以直接由上一题得出其规律，即</p>
<script type="math/tex; mode=display">
f(n) = f(n-1)+f(n-2)+\cdots + f(n-n)</script><p>不过这对做题没什么实质上的帮助，继续化简</p>
<script type="math/tex; mode=display">
f(n-1) = f(n-2)+f(n-3)+\cdots + f(n-n)</script><p>得</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(n) =& 2 \times f(n-1)\\
=&2^{n-1} \times f(1)\\
=&2^{n-1}
\end{aligned}</script><p>那么这个题比上一个题还要简单了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 453k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(number &lt;= <span class="number">2</span>)</span><br><span class="line">               <span class="keyword">return</span> number;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>&lt;&lt;(number<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10. 矩形覆盖"></a>10. 矩形覆盖</h3><ul>
<li>题目描述</li>
</ul>
<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p>&emsp;&emsp;稍微分析就能看出，当有一块矩形横着放的时候，一定有另一块矩形在它的正下方横着放，那么相当于有1*2的矩形和2*2的矩形去覆盖。实质上就与跳台阶问题相同了，就是一个斐波那契数列问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++  3ms 484k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">int</span> a1 = <span class="number">1</span>, a2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++)&#123;</span><br><span class="line">            a2 = a2 + a1;</span><br><span class="line">            a1 = a2 - a1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a2 ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h3><ul>
<li>题目描述</li>
</ul>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>&emsp;&emsp;这题常规做法可以让n与1做与运算，再右移，如此迭代可计算1的个数。不过可以通过二进制减法的借位来实现一个快速算法。二进制数减1时，会向左边一直借位，直到有一个位是1可以让它借位为止。比如<code>10100-1 = 10011</code>，在找到第三位的1后便停止了。不会影响到更左边的1，而第三位后面的位全部反转成1，但将被减数与得到的结果相与之后就会变成0。因此每进行这样一个过程就会去掉原数中的一个 <code>1</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 472k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)&#123;</span><br><span class="line">             n = (n<span class="number">-1</span>)&amp;n;</span><br><span class="line">             count++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="12-前奇后偶"><a href="#12-前奇后偶" class="headerlink" title="12. 前奇后偶"></a>12. 前奇后偶</h3><ul>
<li>题目描述</li>
</ul>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>&emsp;&emsp;要求保持相对位置不变，就是一种稳定排序的思想。不过这里更倾向与用空间换时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 500k  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; odd,even;</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>,count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">array</span>.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">array</span>[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                odd.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                even.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;odd.size(); i++)</span><br><span class="line">            <span class="built_in">array</span>[i] = odd[i];</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=odd.size(),j=<span class="number">0</span>; i&lt;odd.size()+even.size(); i++,j++)</span><br><span class="line">             <span class="built_in">array</span>[i] = even[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="13-链表的倒数第k个节点"><a href="#13-链表的倒数第k个节点" class="headerlink" title="13. 链表的倒数第k个节点"></a>13. 链表的倒数第k个节点</h3><ul>
<li>题目描述</li>
</ul>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p>&emsp;&emsp;注意这个题返回的是节点，而不是节点的值。既然返回倒数的值，链表只能顺序遍历，那么肯定需要记录之前访问过的节点。倒数第k个只需要在访问到第k个的时候，使用另一个指针与最开始的指针同步遍历即可。开始以为返回节点值，还想用循环数组来保存k个值，看起来不太聪明的亚子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 484k </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* p = pListHead, *q = pListHead;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;k)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; k)</span><br><span class="line">            q = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="14-反转链表"><a href="#14-反转链表" class="headerlink" title="14. 反转链表"></a>14. 反转链表</h3><ul>
<li>题目描述</li>
</ul>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p>方法一：头插法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 4ms 480k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>, * curr = pHead, * t;</span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            t = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = head;</span><br><span class="line">            head = curr;</span><br><span class="line">            curr = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：原地逆序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 468k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode *curr = pHead, *pre=<span class="literal">nullptr</span>, *next;</span><br><span class="line">        <span class="keyword">if</span>(!curr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">//注意是无头结点的链表，链表空不是判断curr-&gt;next==nullptr,而是curr == nullptr</span></span><br><span class="line">        <span class="keyword">while</span>(curr-&gt;next)&#123;</span><br><span class="line">            next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意这里的循环条件是curr-&gt;next != nullptr，因为返回的是curr，不过若返回pre就可以省掉这一步。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode *curr = pHead, *pre=<span class="literal">nullptr</span>, *next;</span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;明明是两种思路写的代码，结果原地逆序和头插法代码写得一模一样了。。</p>
<h3 id="15-合并链表"><a href="#15-合并链表" class="headerlink" title="15. 合并链表"></a>15. 合并链表</h3><ul>
<li>题目描述</li>
</ul>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>&emsp;&emsp;很基础的题，注意需要新建一个表头来指第一个元素，返回前记得释放内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 484k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* p1=pHead1, *p2=pHead2;</span><br><span class="line">        ListNode* L = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* p3 = L;</span><br><span class="line">        <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &lt;= p2-&gt;val)&#123;</span><br><span class="line">                p3-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p3-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p3 = p3-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1)</span><br><span class="line">            p3-&gt;next = p1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p3-&gt;next = p2;</span><br><span class="line">        p3 = L-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> L;</span><br><span class="line">        <span class="keyword">return</span> p3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="16-树的子结构"><a href="#16-树的子结构" class="headerlink" title="16.树的子结构"></a>16.树的子结构</h3><ul>
<li>题目描述</li>
</ul>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">树A：</span><br><span class="line">	<span class="number">8</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">8</span>    <span class="number">7</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">7</span></span><br><span class="line">  </span><br><span class="line">树B：</span><br><span class="line">	<span class="number">8</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">9</span>    <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此题类似与字符串中的查找子串的问题，只是数据结构由字符串变成了树。于是查找过程由查找字符串的相等首字符变为相等根节点，遍历B串验证是否是子串变为遍历B树验证是否是子树。</p>
<p>&emsp;&emsp;查找相同根节点是在A树中查找，验证是否是子树是同时遍历。注意在查找根节点时，不可先判断节点的$val$是否相等，再返回$isSubtree()$函数，这样做的结果会使该函数只验证第一个与B树根节点相同的节点处是否是根节点。如样例中便只会判断第一个8所在处是否是子树。这里也可利用或运算的短路特性，讲判断子树与查找根节点放在同一语句中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 4ms 480k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">NULL</span> || pRoot2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(isSubtree(pRoot1,pRoot2))<span class="comment">//注意不可先判断两个节点值是否相等再return函数值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> HasSubtree(pRoot1-&gt;left, pRoot2) || HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span>  isSubtree(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; isSubtree(pRoot1-&gt;right, pRoot2-&gt;right);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="17-二叉树的镜像"><a href="#17-二叉树的镜像" class="headerlink" title="17.二叉树的镜像"></a>17.二叉树的镜像</h3><ul>
<li>题目描述</li>
</ul>
<blockquote>
<p>使二叉树左右对称。</p>
</blockquote>
<p>&emsp;&emsp;对每个根节点的左右节点进行交换即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        TreeNode* tmp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = tmp ;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="18-顺时针打印矩阵"><a href="#18-顺时针打印矩阵" class="headerlink" title="18.顺时针打印矩阵"></a>18.顺时针打印矩阵</h3><ul>
<li>题目描述</li>
</ul>
<blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<p>&emsp;&emsp;从里到外打印矩阵，则顺时针遍历一圈为一个周期。主要需要控制的是下标的运动方向，以及不是方阵时最后只剩一行或一列时避免重复访问的情况。</p>
<p>方法一：控制边界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 372ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, top = <span class="number">0</span>, right = column<span class="number">-1</span>, bottom = row<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( left &lt;= right &amp;&amp; top &lt;= bottom )&#123;</span><br><span class="line">            <span class="keyword">for</span>( j=left; j&lt;=right; j++ )</span><br><span class="line">                res.push_back(matrix[top][j]);</span><br><span class="line">            <span class="keyword">for</span>(i=top+<span class="number">1</span>; i&lt;=bottom; i++)</span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            <span class="keyword">if</span>(top!=bottom) <span class="comment">//如果剩余一行，则不能再次横向扫描，会重复</span></span><br><span class="line">                <span class="keyword">for</span>(j=right<span class="number">-1</span>; j&gt;=left; j--)</span><br><span class="line">                    res.push_back(matrix[bottom][j]);</span><br><span class="line">            <span class="keyword">if</span>(left!=right)<span class="comment">//如果剩余一列，则不能再次纵向扫描。</span></span><br><span class="line">                <span class="keyword">for</span>(i=bottom<span class="number">-1</span>; i&gt;top; i--)</span><br><span class="line">                    res.push_back(matrix[i][left]);</span><br><span class="line">            left++;right--;top++;bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：控制方向</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 480k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st(row, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(column, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> cycle = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>; t &lt; row*column; t++)&#123;</span><br><span class="line">            res.push_back(matrix[i][j]);</span><br><span class="line">            st[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> a= i + dx[cycle], b =j + dy[cycle];</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">0</span> || a&gt;=row || b&lt;<span class="number">0</span> || b&gt;=column || st[a][b])&#123;</span><br><span class="line">                cycle = (cycle+<span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                j += dy[cycle];</span><br><span class="line">                i += dx[cycle];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = a, j = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="19-判断栈的压入与弹出序列"><a href="#19-判断栈的压入与弹出序列" class="headerlink" title="19. 判断栈的压入与弹出序列"></a>19. 判断栈的压入与弹出序列</h3><ul>
<li>题目描述</li>
</ul>
<blockquote>
<p>​    输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<p>&emsp;&emsp;首先一定需要按照给出的压入序列让其入栈，需要判断的是弹出序列是否可能。因此一个做法就是按照其给出的数据模拟一遍这个过程。需要注意的是在入栈的过程中有可能会出现出栈操作 ，因此需一个一个入栈，并且根据出栈序列判断是否需要出栈。若是合法序列，程序执行完毕后栈应是空的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 480k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pushV.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            s.push(pushV[i]);</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() == popV[j] )&#123; <span class="comment">//当心访问空栈</span></span><br><span class="line">                s.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="20-二叉树层序遍历"><a href="#20-二叉树层序遍历" class="headerlink" title="20.二叉树层序遍历"></a>20.二叉树层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            res.push_back(que.front()-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(que.front()-&gt;left)</span><br><span class="line">                que.push(que.front()-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(que.front()-&gt;right)</span><br><span class="line">                que.push(que.front()-&gt;right);</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="21-二叉搜索树的后序遍历"><a href="#21-二叉搜索树的后序遍历" class="headerlink" title="21.二叉搜索树的后序遍历"></a>21.二叉搜索树的后序遍历</h3><ul>
<li>题目描述</li>
</ul>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<p>&emsp;&emsp;即给出一个序列，判断其是否是二叉搜索树的后序遍历，二叉搜索树的特点是左子树小于右子树，后序遍历的特点是最后一个数是根节点。因此可根据根节点将树分为左右子树，递归的对它们的大小关系进行判断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sequence.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(--n)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(sequence[i++] &lt; sequence[n]);</span><br><span class="line">            <span class="keyword">while</span>(sequence[i++] &gt; sequence[n]);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="22-二叉树中和为某值的路径"><a href="#22-二叉树中和为某值的路径" class="headerlink" title="22.二叉树中和为某值的路径"></a>22.二叉树中和为某值的路径</h3><ul>
<li>题目描述</li>
</ul>
<blockquote>
<p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。</p>
<p>从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>例：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给出二叉树如下所示，并给出num=<span class="number">22</span>。</span><br><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">6</span></span><br><span class="line">   /   / \</span><br><span class="line">  <span class="number">12</span>  <span class="number">13</span>  <span class="number">6</span></span><br><span class="line"> /  \    / \</span><br><span class="line"><span class="number">9</span>    <span class="number">1</span>  <span class="number">5</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出：[[<span class="number">5</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;本题在遍历二叉树的基础上，添加了要求——计算到各个叶子结点的路径和，判断与输入整数是否相同，同时需要保存这些满足条件的路径。因为路径是从上到下的，所以使用普通的深度遍历，利用$dfs$的回溯特性，我们只需使用一个$path$向量来存储当前走过的路径，遍历过程中若满足是叶结点且路径和为$num$则将$path$添加进$res$列表。遇到叶节点时开始返回，返回前弹出$path$保存的当前结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> num) &#123;</span><br><span class="line">        dfs(root, num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        num -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !num) res.push_back(path);</span><br><span class="line">        dfs(root-&gt;left,num);</span><br><span class="line">        dfs(root-&gt;right,num);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="30-丑数"><a href="#30-丑数" class="headerlink" title="30. 丑数"></a>30. 丑数</h3><ul>
<li>题目描述</li>
</ul>
<blockquote>
<p>我们把只包含质因子2、3和5的数称作丑数（Ugly Number）。</p>
<p>例如6、8都是丑数，但14不是，因为它包含质因子7。</p>
<p>求第n个丑数的值。</p>
</blockquote>
<p>&emsp;&emsp;按丑数的定义，它实际上就是由2,3,5作为因子的数的集合。这个集合有个规律：所有丑数都能被拆分为其因子2,3,5的组合，即$ugly = 2x+3y+5z$ 。既然如此，判别一个数是否是丑数的方法就是不断用除法将其中的2,3,5因子剥离出来。本题求第n个丑数的值，那么暴力做法就是依次判断前n个丑数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++  TLE</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getUglyNumber</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">7</span>) <span class="keyword">return</span> index;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>,num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; index)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isUgly(num))</span><br><span class="line">                count++;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            num /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            num /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            num /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然而很不幸，这种暴力做法会TLE。要求的是第n个丑数，挨个对前n个判断是否是丑数复杂度确实太大。丑数是由这三个因子的乘积组合而成的，那么后面的丑数一定是由前面的丑数乘以这三个因子中的某个得到的。那么这个问题就可以看作一个动态规划问题，通过已求得的丑数分别乘三个因子，得到后面的丑数，然后选取一个最小的加入已得到丑数，再将这个刚加入的数乘因子，归入后面的待选丑数。如此递推便能依次找到前n个丑数。</p>
<p>&emsp;&emsp;每个因子加入已知丑数集合时，<strong>都会乘三个因子</strong>得到三个待选丑数。然而这些数中有些是会重复的，比如得到了2,3两个丑数，它们分别乘2、3、5得到两个6。所以不能直接将乘积结果加入，但由于丑数是有序且不重复的，因此可以每次只将待选丑数中最小的那个纳入。为了让每个已纳入的丑数乘三个因子后的丑数参与待选，可以设置3个指针，指向已纳入的丑数，如果刚刚纳入的是该指针对应因子乘积的结果，则该指针可前移一位，下次便可计算下一个丑数对它因子的乘积。这个方法也解决了重复的问题，因为相同的丑数会使其对应的因子指针都前移。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getUglyNumber</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">7</span>) <span class="keyword">return</span> index;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</span><br><span class="line">        <span class="keyword">int</span> p2=<span class="number">0</span>, p3=<span class="number">0</span>, p5=<span class="number">0</span>, ugly=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">array</span>.push_back(ugly);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>.size() &lt; index)&#123;</span><br><span class="line">            ugly = min(<span class="built_in">array</span>[p2]*<span class="number">2</span>, min(<span class="built_in">array</span>[p3]*<span class="number">3</span>, <span class="built_in">array</span>[p5]*<span class="number">5</span> ));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[p2]*<span class="number">2</span> == ugly) p2++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[p3]*<span class="number">3</span> == ugly) p3++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[p5]*<span class="number">5</span> == ugly) p5++;<span class="comment">//维护对应指针</span></span><br><span class="line">            <span class="built_in">array</span>.push_back(ugly);       <span class="comment">//每次添加一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[index<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../../../../tags/刷题/" rel="tag"># 刷题</a>
          
            <a href="../../../../../tags/剑指offer/" rel="tag"># 剑指offer</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="../../../22/ML/CRF/条件随机场/" rel="next" title="条件随机场">
                <i class="fa fa-chevron-left"></i> 条件随机场
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="../../../25/Leetcode/字符串/" rel="prev" title="字符串">
                字符串 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">brezezee</p>
              <p class="site-description motion-element" itemprop="description">靡不有初，鲜克有终</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="https://brezezee.github.io/archives">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="../../../../../categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="../../../../../tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-二维数组-vector-查找"><span class="nav-text">1. 二维数组(vector)查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-字符串空格替换"><span class="nav-text">2. 字符串空格替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-链表逆序"><span class="nav-text">3. 链表逆序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-重建二叉树（前，中序）"><span class="nav-text">4. 重建二叉树（前，中序）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-双栈队列"><span class="nav-text">5. 双栈队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-旋转数组的最小数字"><span class="nav-text">6. 旋转数组的最小数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-斐波那契数列"><span class="nav-text">7. 斐波那契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-矩阵快速幂留坑"><span class="nav-text">7.1 矩阵快速幂留坑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-跳台阶"><span class="nav-text">8. 跳台阶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-变态跳台阶"><span class="nav-text">9. 变态跳台阶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-矩形覆盖"><span class="nav-text">10. 矩形覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-二进制中1的个数"><span class="nav-text">11. 二进制中1的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-前奇后偶"><span class="nav-text">12. 前奇后偶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-链表的倒数第k个节点"><span class="nav-text">13. 链表的倒数第k个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-反转链表"><span class="nav-text">14. 反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-合并链表"><span class="nav-text">15. 合并链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-树的子结构"><span class="nav-text">16.树的子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-二叉树的镜像"><span class="nav-text">17.二叉树的镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-顺时针打印矩阵"><span class="nav-text">18.顺时针打印矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-判断栈的压入与弹出序列"><span class="nav-text">19. 判断栈的压入与弹出序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-二叉树层序遍历"><span class="nav-text">20.二叉树层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-二叉搜索树的后序遍历"><span class="nav-text">21.二叉搜索树的后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-二叉树中和为某值的路径"><span class="nav-text">22.二叉树中和为某值的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-丑数"><span class="nav-text">30. 丑数</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">brezezee</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">66.3k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="../../../../../lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="../../../../../lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="../../../../../lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="../../../../../lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../../../../lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../../../../lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="../../../../../js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="../../../../../js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="../../../../../js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="../../../../../js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="../../../../../js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://brezezee.github.io/2019/08/23/剑指offer/剑指offer/';
          this.page.identifier = '2019/08/23/剑指offer/剑指offer/';
          this.page.title = '剑指offer';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
