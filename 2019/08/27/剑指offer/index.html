<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="../../../../lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="../../../../lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="../../../../lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="../../../../css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="../../../../images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="../../../../images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="../../../../images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="../../../../images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="剑指offer,">










<meta name="description" content="1. 二维数组(vector)查找 题目描述  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 法一： 左下/右上查找 &amp;emsp;&amp;emsp;该题给出的数组单看行或者列都是单增的，但是中间某点只能确定其左上的区域是小于它的，并不能确定在其余三个区域中的">
<meta name="keywords" content="剑指offer">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer">
<meta property="og:url" content="https://brezezee.github.io/2019/08/27/剑指offer/index.html">
<meta property="og:site_name" content="brezezee">
<meta property="og:description" content="1. 二维数组(vector)查找 题目描述  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 法一： 左下/右上查找 &amp;emsp;&amp;emsp;该题给出的数组单看行或者列都是单增的，但是中间某点只能确定其左上的区域是小于它的，并不能确定在其余三个区域中的">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://brezezee.github.io/2019/08/27/剑指offer/1566483039647.png">
<meta property="og:updated_time" content="2019-08-28T04:37:01.460Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer">
<meta name="twitter:description" content="1. 二维数组(vector)查找 题目描述  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 法一： 左下/右上查找 &amp;emsp;&amp;emsp;该题给出的数组单看行或者列都是单增的，但是中间某点只能确定其左上的区域是小于它的，并不能确定在其余三个区域中的">
<meta name="twitter:image" content="https://brezezee.github.io/2019/08/27/剑指offer/1566483039647.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://brezezee.github.io/2019/08/27/剑指offer/">





  <title>剑指offer | brezezee</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">brezezee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="https://brezezee.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="https://brezezee.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="https://brezezee.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-categories"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="https://brezezee.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archives"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="https://brezezee.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-about"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://brezezee.github.io">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brezezee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brezezee">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">剑指offer</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-27T16:27:51+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="../../../../categories/code-practice/" itemprop="url" rel="index">
                    <span itemprop="name">刷题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <h3 id="1-二维数组-vector-查找"><a href="#1-二维数组-vector-查找" class="headerlink" title="1. 二维数组(vector)查找"></a>1. 二维数组(vector)查找</h3><ul>
<li><strong>题目描述</strong></li>
</ul>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>法一：</strong> 左下/右上查找</p>
<p>&emsp;&emsp;该题给出的数组单看行或者列都是单增的，但是中间某点只能确定其左上的区域是小于它的，并不能确定在其余三个区域中的哪一个。因为按从最左上开始寻找是不容易找到较好的方法的，于是可从左下角或者右上角开始寻找，这两个位置可以看作一个特殊的<strong>“中点”</strong>，它将它所在的行和列正好分割。它所在的行都大于它，所在的列都小于它。如此当target小于它时，按列查找，大于它时，按行查找。复杂度$O(n+m)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size_i=<span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> size_j=<span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(size_i==<span class="number">0</span> || size_j==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//判断空数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> i = size_i<span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &gt;= <span class="number">0</span> &amp;&amp; j &lt; size_j )&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; <span class="built_in">array</span>[i][j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; <span class="built_in">array</span>[i][j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>法二：</strong> 旋转折半查找</p>
<p>&emsp;&emsp; 这种形式的数据还有一个规律，以边界上的点作切割，其右边部分都是大于它的，因为按行按列单增。那么可以在四个边界上查找，依次旋转，每次进行的折半查找都能排除掉其右边的切割部分。不断进行直到最后区域只剩一个点为止。</p>
<p><img src="1566483039647.png" alt="1566483039647"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">array</span>.size()==<span class="number">0</span> || <span class="built_in">array</span>[<span class="number">0</span>].size()==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">int</span> top = <span class="number">0</span>, bottom = <span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">           <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">array</span>[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">           <span class="keyword">int</span> sLeft = <span class="number">0</span>, sRight = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> sTop = <span class="number">0</span>, sBottom = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (;left&lt;right || top&lt;bottom;) &#123;</span><br><span class="line">               <span class="comment">//对上边界进行折半，可以缩小右边界</span></span><br><span class="line">               sLeft = left, sRight = right;</span><br><span class="line">               <span class="keyword">for</span> (;sLeft&lt;=sRight;) &#123;</span><br><span class="line">                   mid = (sLeft + sRight) / <span class="number">2</span>;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="built_in">array</span>[top][mid]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[top][mid]&lt;target) sLeft = mid+<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span> sRight = mid<span class="number">-1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (mid&lt;right) right = mid; <span class="comment">//利用终止点缩小右边界</span></span><br><span class="line">               top++;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//对右边界进行折半，可以缩小上边界</span></span><br><span class="line">               sTop = top, sBottom = bottom;</span><br><span class="line">               <span class="keyword">for</span> (;sTop&lt;=sBottom;) &#123;</span><br><span class="line">                   mid = (sTop + sBottom) / <span class="number">2</span>;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="built_in">array</span>[mid][right]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[mid][right]&lt;target) sTop = mid+<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span> sBottom = mid<span class="number">-1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (top&lt;mid) top = mid; <span class="comment">//利用终止点缩小上边界</span></span><br><span class="line">               right--;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//对下边界进行折半，可以缩小左边界</span></span><br><span class="line">               sLeft = left, sRight = right;</span><br><span class="line">               <span class="keyword">for</span> (;sLeft&lt;=sRight;) &#123;</span><br><span class="line">                   mid = (sLeft + sRight) / <span class="number">2</span>;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="built_in">array</span>[bottom][mid]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[bottom][mid]&lt;target) sLeft = mid+<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span> sRight = mid<span class="number">-1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (left&lt;mid) left = mid; <span class="comment">//利用终止点缩小左边界</span></span><br><span class="line">               bottom--;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//对左边界进行折半，可以缩小下边界</span></span><br><span class="line">               sTop = top, sBottom = bottom;</span><br><span class="line">               <span class="keyword">for</span> (;sTop&lt;=sBottom;) &#123;</span><br><span class="line">                   mid = (sTop + sBottom) / <span class="number">2</span>;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="built_in">array</span>[mid][left]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[mid][left]&lt;target) sTop = mid+<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span> sBottom = mid<span class="number">-1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (mid&lt;bottom) bottom = mid; <span class="comment">//利用终止点缩小下边界</span></span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">array</span>[top][left]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>法三：</strong> 十字分割</p>
<p>&emsp;&emsp;若将该数组按中间某点分为四个区域，在其主对角线上的两个区域（也就是左上和右下）是比较有特点的，左上的全部小于该点，右下的全部大于该点。那么可在其主对角线上先搜索一遍，如果没找到，就可以排除这两个区域，再对左下和右上两个区域进行如此递归。显然用折半查找比较合适。但是当该数组不是方阵的时候效率很低。</p>
<h3 id="2-字符串空格替换"><a href="#2-字符串空格替换" class="headerlink" title="2. 字符串空格替换"></a>2. 字符串空格替换</h3><ul>
<li>题目描述</li>
</ul>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>&emsp;&emsp;这个题中提供的字符串以字符数组的形式给出，需要将一个空格替换为三个字符，因此数组的长度会变。若是从前面开始直接遇到一个空格 便替换，后面剩余的字符串都需要往后移动，因此用从后往前替换的方法。从后往前则需要事先确定替换后的数组长度，因此先遍历一遍，得到空格数量。然后从尾部开始遇到空格便替换即可。下面这种在替换过程中计算下标的写法让代码较简洁一些，但是有许多乘积运算。因此考虑效率最好还是先计算出总长度，然后—即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[i + <span class="number">2</span>*count]=<span class="string">'0'</span>;</span><br><span class="line">                str[i + <span class="number">2</span>*count - <span class="number">1</span>] = <span class="string">'2'</span>;</span><br><span class="line">                str[i + <span class="number">2</span>*count - <span class="number">2</span>] = <span class="string">'%'</span>;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str[i + <span class="number">2</span>*count] = str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-链表逆序"><a href="#3-链表逆序" class="headerlink" title="3. 链表逆序"></a>3. 链表逆序</h3><ul>
<li>题目描述</li>
</ul>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<p>&emsp;&emsp;思路较多，可以递归、栈、反向迭代器、链表逆序等。</p>
<p>法一：反向迭代器(3ms，472k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res.rbegin(),res.rend());  <span class="comment">//反向迭代器创建一个临时逆序向量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法二：递归 (3ms，484k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;  <span class="comment">//递归时不能将其定义在函数内部，局部变量退出被删除</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">             printListFromTailToHead(p-&gt;next);</span><br><span class="line">          &#125;</span><br><span class="line">        res.push_back(p-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法三：栈(3ms，500k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            stk.push(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            res.push_back(stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法四：链表逆序(3ms,512k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(struct ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        ListNode *buf=head;</span><br><span class="line">        ListNode *pre=buf;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span>)&#123; <span class="comment">//head不再需要，作为过渡指针</span></span><br><span class="line">            buf=head-&gt;next;</span><br><span class="line">            head-&gt;next=buf-&gt;next;</span><br><span class="line">            buf-&gt;next=pre;            </span><br><span class="line">            pre=buf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(buf)&#123;</span><br><span class="line">            vec.push_back(buf-&gt;val);</span><br><span class="line">            buf=buf-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-重建二叉树（前，中序）"><a href="#4-重建二叉树（前，中序）" class="headerlink" title="4. 重建二叉树（前，中序）"></a>4. 重建二叉树（前，中序）</h3><ul>
<li>题目描述</li>
</ul>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>&emsp;&emsp;根据前序和中序重建二叉树，前序可确定当前序列中的根节点，根据根节点可在中序中找到根节点来分割当前根节点的左右子树。而对于在中序遍历中划分出来的左右子树的长度与先序遍历的长度一定是相同的，所以不断迭代找根节点，划分左右子树的过程便能重建该二叉树。</p>
<p>&emsp;&emsp;对于数组的划分，python有切片功能，用python实现代码相当简洁：(50ms,5321k)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(pre.pop(<span class="number">0</span>))</span><br><span class="line">        index = tin.index(root.val)</span><br><span class="line">        root.left = self.reConstructBinaryTree(pre, tin[:index]) </span><br><span class="line">        <span class="comment">#每次递归都会将pre出栈一个，因此不需要管它，它的长度变化满足左右子树</span></span><br><span class="line">        root.right = self.reConstructBinaryTree(pre, tin[index + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>C++不能直接切分，就需要手动给出每个子树的起始和终止范围。虽然写起来较python复杂一点，但效率高多了。(4ms,523k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in)</span> </span>&#123;</span><br><span class="line">        TreeNode* root=ConstructBinaryTree(pre, <span class="number">0</span>, pre.size()<span class="number">-1</span>, in, <span class="number">0</span>, in.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">ConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="keyword">int</span> startPre,<span class="keyword">int</span> endPre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in,<span class="keyword">int</span> startIn,<span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startPre&gt;endPre)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        <span class="keyword">if</span>(startPre == endPre)</span><br><span class="line">                <span class="keyword">return</span> root;      <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == pre[startPre])&#123;</span><br><span class="line">               <span class="keyword">int</span> len_of_left = i-startIn;</span><br><span class="line">               <span class="keyword">int</span> len_of_right = endIn-i;</span><br><span class="line">               root-&gt;left = ConstructBinaryTree(pre, startPre+<span class="number">1</span>, startPre+len_of_left, in, startIn, i<span class="number">-1</span>);</span><br><span class="line">               root-&gt;right = ConstructBinaryTree(pre, startPre+len_of_left+<span class="number">1</span>, endPre, in, i+<span class="number">1</span>, endIn);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-双栈队列"><a href="#5-双栈队列" class="headerlink" title="5. 双栈队列"></a>5. 双栈队列</h3><ul>
<li>题目描述</li>
</ul>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p>&emsp;&emsp;队列与栈的主要区别是出栈方向不同，那么即可以维护入栈时的顺序，可以维护出栈时的顺序。但是维护入栈顺序每次来新数据都需要将已经入栈的数据来回倒换，因此选择维护出栈顺序。出队列时，将A栈中数据倒换到B栈，从B栈中出去的数据便是正常的队列顺序。且这个过程中，已经倒换的B栈的数据不需要再倒换回去，因为它们相对于后面新入栈的数据就是“先来的”，就应当先出栈。所以pop操作先检查B栈是否有数据，有则直接pop，无则将A栈数据全部倒换到B栈。（3ms,356k)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.empty() &amp;&amp;stack2.empty())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                        stack2.push(stack1.top());</span><br><span class="line">                        stack1.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h3><ul>
<li>题目描述</li>
</ul>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>&emsp;&emsp;如果是严格递增的数组，那么使用二分法的时候只有两种情况：一是mid&gt;high，这时最小数字一定在后半部分。而是mid<high，这时最小数字在前半部分。但非递减数组的话就有可能存在相等的情况，比如`1 0 1 1`和`1 1`，这时无法确定最小数字的位置在哪边。因此只能慢慢减少high或增加low来缩小范围，当然这是low="mid=high的情况，我们可以判断mid与low的大小关系来剪去一部分多余操作。若此时low<mid，那么low即是最小数字，low">mid时，最小数字可能是mid或在左边，比如<code>2 3 1 1 1</code>,<code>3 1 2 2 2</code>，令high=mid即可，但若mid=low，真的只能挨个试了。</high，这时最小数字在前半部分。但非递减数组的话就有可能存在相等的情况，比如`1></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ Solution 28ms,603k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>, high = rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rotateArray[low]&lt;rotateArray[high])</span><br><span class="line">                    <span class="keyword">return</span> rotateArray[low];  <span class="comment">//剪枝</span></span><br><span class="line">                mid  = (low + high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[high])&#123;</span><br><span class="line">                        low = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[high])&#123;</span><br><span class="line">                        high = mid ;<span class="comment">//下取整</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[low])</span><br><span class="line">                                <span class="keyword">return</span> rotateArray[low]; <span class="comment">//剪枝</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[low])</span><br><span class="line">                            	high = mid;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                high--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rotateArray[high];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;虽然理论上在mid = high的时候可以比较mid 与 low进行剪枝，但实际运行的效率好像并没有提高。可能没有人这么无聊做这种测试数据吧，哈哈。</p>
<h3 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h3><ul>
<li>题目描述</li>
</ul>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p>
<p>n&lt;=39</p>
<p>&emsp;&emsp;提到斐波那契数列想到的可能是递归，但是递归的空间复杂度和时间复杂度都比较高，有较多的重复计算，并且其调用栈会累积，若n过大一定会stack overflow的。但是这个题也不是不能用递归，对于调用栈的问题，可以使用尾递归的方式避免。尾递归可以参考这篇<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">博客</a>，简单来讲就是让递归调用函数发生在最后一步，即return，并且只能return函数，不能做运算，可以将需要的变量通过函数参数方式传递。这样干干净净的调用时系统不会保存在函数局部用过的变量内容，只需要记录1个调用位置，于是避免了堆栈溢出的风险。</p>
<p>&emsp;&emsp;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 尾递归 4ms 484k  O(n) O(n)直接递归的话632ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> fun(n, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> a2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> fun(n<span class="number">-1</span>, a2, a1+a2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种改造成尾递归的方式相当于将n当成了一个计数变量，<code>a1,a2</code>用来计算实际上的Fibonacci数列值。Fibonacci就是前两个Fibonacci数列的和，<code>a1,a2</code>保存的就是它们的值。且计算从数列的最小情况开始计算，避免了重复计算。</p>
<p>显然，这种方式可以直接改造成循环来实现，n只是一个计数变量而已。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 循环 3ms 464k  O(n) O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="number">0</span>, a2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a2 = a2 + a1;</span><br><span class="line">        a1 = a2 - a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看了别人的代码发现还有更简化的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="number">0</span>, a2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        a2 = a2 + a1;</span><br><span class="line">        a1 = a2 - a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-1-矩阵快速幂留坑"><a href="#7-1-矩阵快速幂留坑" class="headerlink" title="7.1 矩阵快速幂留坑"></a>7.1 矩阵快速幂留坑</h4><h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h3><ul>
<li>题目描述</li>
</ul>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>&emsp;&emsp;这是一个找规律的题，可以从开始和结尾两个方向进行分析。首先每次只有两种跳法，跳一步或两步。<strong>从开头来看</strong>：若第一次跳一步，那么后面就剩<code>n-1</code>阶，变成<code>n-1</code>阶的原问题。若第一次跳两步，那么后面剩<code>n-2</code>阶，变成<code>n-2</code>阶的原问题。总共就这两种情况，因此<code>n</code>阶的原问题<code>f(n)</code>可表示为<code>f(n-1)+f(n-2)</code>。这就是上一题的斐波那契数列的递推式。<strong>从结尾来看</strong>：最终结果是跳到n，那么可能出现的最后一跳的位置只可能是<code>n-1</code>和<code>n-2</code>，最后一跳的位置已确定，那么有多少种跳到<code>n-1</code>和<code>`n-2</code>的方案，就有多少种跳到<code>n</code>的方案。同样得到斐波那契数列递推式，不过从实际情况来看并不完全满足斐波那契。当<code>n=2</code>时，有两种情况。按递推式，莫不是<code>n=0</code>时 不跳也算一种方案？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 470k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">int</span> a1 = <span class="number">1</span>, a2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++)&#123;</span><br><span class="line">            a2 = a1 + a2;</span><br><span class="line">            a1 = a2 - a1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h3><ul>
<li>题目描述</li>
</ul>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>&emsp;&emsp;这就是上一个题的扩展，可以直接由上一题得出其规律，即</p>
<script type="math/tex; mode=display">
f(n) = f(n-1)+f(n-2)+\cdots + f(n-n)</script><p>不过这对做题没什么实质上的帮助，继续化简</p>
<script type="math/tex; mode=display">
f(n-1) = f(n-2)+f(n-3)+\cdots + f(n-n)</script><p>得</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(n) =& 2 \times f(n-1)\\
=&2^{n-1} \times f(1)\\
=&2^{n-1}
\end{aligned}</script><p>那么这个题比上一个题还要简单了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 453k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(number &lt;= <span class="number">2</span>)</span><br><span class="line">               <span class="keyword">return</span> number;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>&lt;&lt;(number<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10. 矩形覆盖"></a>10. 矩形覆盖</h3><ul>
<li>题目描述</li>
</ul>
<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p>&emsp;&emsp;稍微分析就能看出，当有一块矩形横着放的时候，一定有另一块矩形在它的正下方横着放，那么相当于有1*2的矩形和2*2的矩形去覆盖。实质上就与跳台阶问题相同了，就是一个斐波那契数列问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++  3ms 484k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">int</span> a1 = <span class="number">1</span>, a2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++)&#123;</span><br><span class="line">            a2 = a2 + a1;</span><br><span class="line">            a1 = a2 - a1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a2 ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h3><ul>
<li>题目描述</li>
</ul>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>&emsp;&emsp;这题常规做法可以让n与1做与运算，再右移，如此迭代可计算1的个数。不过可以通过二进制减法的借位来实现一个快速算法。二进制数减1时，会向左边一直借位，直到有一个位是1可以让它借位为止。比如<code>10100-1 = 10011</code>，在找到第三位的1后便停止了。不会影响到更左边的1，而第三位后面的位全部反转成1，但将被减数与得到的结果相与之后就会变成0。因此每进行这样一个过程就会去掉原数中的一个 <code>1</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 472k</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)&#123;</span><br><span class="line">             n = (n<span class="number">-1</span>)&amp;n;</span><br><span class="line">             count++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h3><ul>
<li>题目描述</li>
</ul>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和exponent不同时为0</p>
<p>&emsp;&emsp;直接用快速幂就行了。当幂次较高时，需要做较多的乘积运算。比如求$b^{200}$，直接算需要199次乘积运算。幂次是整数，那么就一定可拆解，如$b^{100}\times b^{100}$ ，这样就能只计算100次。但这样还是比较多，如何拆解有最大收益呢。乘积的过程中会有很多中间值$b^2,b^3,\cdots,b^{100}$，为了尽可能让这些中间值利用起来，将其按幂的二进制中含1的位来进行拆解。</p>
<script type="math/tex; mode=display">
\begin{aligned}
b^{200}= \;b^{11001000}=\; b^{2^7}\times b^{2^6}\times b^{2^3}
\end{aligned}</script><p>&emsp;&emsp;以二进制拆解有一个好处，就是它们之间都是<strong>2次方</strong>的关系，比如$b^{2^7}=b^{2^6}\times b^{2^6}$ 。如此每一个前面计算过的数都能为下一个将要算的数作贡献。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 3ms 480k O(log(n)) </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        n = <span class="built_in">abs</span>(exponent);</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">                ans *= base;</span><br><span class="line">            base *= base;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent&gt;<span class="number">0</span>?ans:(<span class="number">1</span>/ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../../../tags/剑指offer/" rel="tag"># 剑指offer</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="../../22/条件随机场/" rel="next" title="条件随机场">
                <i class="fa fa-chevron-left"></i> 条件随机场
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="../python基础1/" rel="prev" title="python基础语法（一）">
                python基础语法（一） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">brezezee</p>
              <p class="site-description motion-element" itemprop="description">A learning notes blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="https://brezezee.github.io/archives">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="../../../../categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="../../../../tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-二维数组-vector-查找"><span class="nav-text">1. 二维数组(vector)查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-字符串空格替换"><span class="nav-text">2. 字符串空格替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-链表逆序"><span class="nav-text">3. 链表逆序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-重建二叉树（前，中序）"><span class="nav-text">4. 重建二叉树（前，中序）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-双栈队列"><span class="nav-text">5. 双栈队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-旋转数组的最小数字"><span class="nav-text">6. 旋转数组的最小数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-斐波那契数列"><span class="nav-text">7. 斐波那契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-矩阵快速幂留坑"><span class="nav-text">7.1 矩阵快速幂留坑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-跳台阶"><span class="nav-text">8. 跳台阶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-变态跳台阶"><span class="nav-text">9. 变态跳台阶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-矩形覆盖"><span class="nav-text">10. 矩形覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-二进制中1的个数"><span class="nav-text">11. 二进制中1的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-数值的整数次方"><span class="nav-text">12. 数值的整数次方</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">brezezee</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count"></span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="../../../../lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="../../../../lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="../../../../lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="../../../../lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../../../lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../../../lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="../../../../js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="../../../../js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="../../../../js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="../../../../js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="../../../../js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
