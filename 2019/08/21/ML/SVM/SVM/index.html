<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="../../../../../../lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="../../../../../../lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="../../../../../../css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="../../../../../../images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="../../../../../../images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="../../../../../../images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="../../../../../../images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="机器学习,SVM,SMO,">










<meta name="description" content="&amp;emsp;&amp;emsp;支持向量机是一种二分类模型，它以间隔最大作为优化目标，因此它比感知机仅仅以误分类推动的模型要优胜不少。数据线性可分时，SVM直接以间隔最大训练出一个线性分类模型。当数据线性不可分时，SVM通过软间隔最大化解决这种问题。此时的模型仍是一个线性模型，若采用核方法和软间隔最大化，则得到一个非线性模型。可以看到SVM在解决变复杂的情况时是逐步改进的。 1. 定义&amp;emsp;&amp;ems">
<meta name="keywords" content="机器学习,SVM,SMO">
<meta property="og:type" content="article">
<meta property="og:title" content="SVM推导">
<meta property="og:url" content="https://brezezee.github.io/2019/08/21/ML/SVM/SVM/index.html">
<meta property="og:site_name" content="brezezee">
<meta property="og:description" content="&amp;emsp;&amp;emsp;支持向量机是一种二分类模型，它以间隔最大作为优化目标，因此它比感知机仅仅以误分类推动的模型要优胜不少。数据线性可分时，SVM直接以间隔最大训练出一个线性分类模型。当数据线性不可分时，SVM通过软间隔最大化解决这种问题。此时的模型仍是一个线性模型，若采用核方法和软间隔最大化，则得到一个非线性模型。可以看到SVM在解决变复杂的情况时是逐步改进的。 1. 定义&amp;emsp;&amp;ems">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://i.loli.net/2019/08/14/i2t9IzB1c7qQJVv.jpg">
<meta property="og:image" content="https://i.loli.net/2019/08/27/PyvipKD32dVbUHT.png">
<meta property="og:image" content="https://i.loli.net/2019/08/14/MLGToeqSHXImVQC.png">
<meta property="og:image" content="https://i.loli.net/2019/08/14/h8HJUOzANEdFcDe.png">
<meta property="og:image" content="https://i.loli.net/2019/08/14/Rjc2Nl3XLP1AwDo.jpg">
<meta property="og:image" content="https://i.loli.net/2019/08/14/Rjc2Nl3XLP1AwDo.jpg">
<meta property="og:updated_time" content="2019-12-01T01:57:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SVM推导">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;支持向量机是一种二分类模型，它以间隔最大作为优化目标，因此它比感知机仅仅以误分类推动的模型要优胜不少。数据线性可分时，SVM直接以间隔最大训练出一个线性分类模型。当数据线性不可分时，SVM通过软间隔最大化解决这种问题。此时的模型仍是一个线性模型，若采用核方法和软间隔最大化，则得到一个非线性模型。可以看到SVM在解决变复杂的情况时是逐步改进的。 1. 定义&amp;emsp;&amp;ems">
<meta name="twitter:image" content="https://i.loli.net/2019/08/14/i2t9IzB1c7qQJVv.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://brezezee.github.io/2019/08/21/ML/SVM/SVM/">





  <title>SVM推导 | brezezee</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">brezezee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="https://brezezee.github.io" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="https://brezezee.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="https://brezezee.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-categories"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="https://brezezee.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="https://brezezee.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://brezezee.github.io">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brezezee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../../../../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brezezee">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">SVM推导</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-21T19:32:12+08:00">
                2019-08-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2019-12-01T09:57:01+08:00">
                2019-12-01
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="../../../../../../categories/meachine-learning/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/21/ML/SVM/SVM/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  8.1k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&emsp;&emsp;支持向量机是一种二分类模型，它以间隔最大作为优化目标，因此它比感知机仅仅以误分类推动的模型要优胜不少。数据线性可分时，SVM直接以间隔最大训练出一个线性分类模型。当数据线性不可分时，SVM通过软间隔最大化解决这种问题。此时的模型仍是一个线性模型，若采用核方法和软间隔最大化，则得到一个非线性模型。可以看到SVM在解决变复杂的情况时是逐步改进的。</p>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>&emsp;&emsp;前面已经学习过的线性分类有感知机和$Logistic$回归。感知机对误分类点进行优化，得到一个对训练样本的分类超平面，但这个超平面并不是最优的，而且只能用于数据线性可分的情况。而$Logistic$回归是一个对数线性模型，它将数据映射到0到1之间，对有较大差异的数据有较好适应性。通常，$Logistic$回归中的线性部分$w^Tx+b &gt; 0$时，该模型输出就大于0.5 这时输入$x$被分为$y=1$那一类。</p>
<p>&emsp;&emsp;上面已说到，SVM问题分三个阶段，一是线性可分、二是线性不可分但可放弃部分奇异点用线性分割、三是线性不可分且数据本身就非线性可分。解决这些问题都是一步一步来的，图1 是一个线性可分的SVM示意图，中间是得到的分类超平面，两端虚线是支持向量到超平面的最大间隔线。而这条线上的就是支持向量，支持向量到超平面的间隔是所有样本点中最近的。</p>
<center class="half">
<img src="https://i.loli.net/2019/08/14/i2t9IzB1c7qQJVv.jpg" width="600">
</center>



<p>&emsp;&emsp; 定义:线性可分支持向量机是给定数据集，通过最大间隔法确定的分离超平面</p>
<script type="math/tex; mode=display">
\boldsymbol{w^{\ast}\cdot x} + b^{\ast} = 0</script><p>和分类决策函数</p>
<script type="math/tex; mode=display">
y = sign(\boldsymbol{w^{\ast} \cdot x} + b^{\ast})</script><p>所定义的分类模型。其中sign是符号函数，当$\boldsymbol{w^{\ast}\cdot x} +b^{\ast} &gt; 0$时取 1 ，反之取0 。并且$|w^{\ast}x+b^{\ast}|$越大代表确信度越高。</p>
<h3 id="1-1-函数间隔和几何间隔"><a href="#1-1-函数间隔和几何间隔" class="headerlink" title="1.1 函数间隔和几何间隔"></a>1.1 函数间隔和几何间隔</h3><p>&emsp;&emsp;数据集中，一个点离超平面越远，那么确信其判断正确性的可能就越大，它可以由$\boldsymbol{w\cdot x}+b$来表示。若要建立一个即可判断确信度又能判断其分类正确性的函数，则需要引进一个符号变量，巧合的是$y\in\{-1,1\}$，并且若分类正确 $\boldsymbol{w\cdot x} +b$ 与$y$的符号是一致的。那么可由$y(\boldsymbol{w\cdot x} + b)$来表示分类的正确性和确信度，这就是函数间隔的意义。</p>
<p>&emsp;&emsp;对于给定样本集和超平面，超平面关于样本点$(\boldsymbol{x_i},y_i)$的函数间隔为</p>
<script type="math/tex; mode=display">
\widehat \gamma_i = y_i(\boldsymbol{w\cdot x_i} + b)</script><p>超平面关于数据集的函数间隔为</p>
<script type="math/tex; mode=display">
\widehat \gamma = \underset {i} {min} \;\widehat \gamma _i</script><p>事实上，超平面关于整个数据集的函数间隔就是超平面关于支持向量的函数间隔。显然，我们需要优化的便是这个关于支持向量的间隔，使它最大也就使得超平面对数据集中所有点都有较远距离。</p>
<p>&emsp;&emsp;但是直接对函数间隔最大化有个问题，函数间隔是关于参数$\boldsymbol{w},b$的函数，若$\boldsymbol{w},b$成比例的增加，这时超平面是 不会变 的，但是函数间隔会按相同比例增加。所以直接最大化函数间隔得到的结果肯定是无穷大了，因此需要对其进行规范化。这里对法向量 $w$ 进行标准化，标准化后的结果就是几何间隔.</p>
<script type="math/tex; mode=display">
\gamma_i = y_i\frac { \boldsymbol{w \cdot x_i} +b } {||\boldsymbol{w}||}</script><p>其中，$||\boldsymbol{w}||$ 是第二范式。</p>
<p>&emsp;&emsp;在二维情形下，$\boldsymbol{w}\cdot \boldsymbol{x} + b/ ||w||$就是点到直线的距离公式没加绝对值符号，标准化后的几何间隔就不会因$\boldsymbol{w},b$按比例放缩而产生变化。同样，超平面关于数据集的几何间隔为</p>
<script type="math/tex; mode=display">
\gamma = \underset i {min} \; \gamma_i</script><p>函数间隔与几何间隔只是相差一个标准化因子</p>
<script type="math/tex; mode=display">
\begin{aligned}
\gamma_i &= \frac {\widehat \gamma_i} {||\boldsymbol{w}||}\\
\gamma &= \frac {\widehat \gamma} {||\boldsymbol{w}||}
\end{aligned}</script><h3 id="1-2-间隔最大化"><a href="#1-2-间隔最大化" class="headerlink" title="1.2 间隔最大化"></a>1.2 间隔最大化</h3><p>&emsp;&emsp;定义了几何间隔后，就能通过最大化支持向量到超平面的几何间隔得到一个最优的分类超平面。在感知机中，学习的方法是最小化误差距离。这种方法只要超平面能够正确分类已知的数据，学习过程便结束。而对SVM中最大化几何间隔来说，当还未能正确分类所有样本点时，数据集中几何间隔最小的样本点是负的，此时的最大化过程是找到一个能够正确分割数据集的超平面。当几何间隔学习到大于0的时侯，超平面已能将数据集正确分割，但学习过程不会停止，SVM希望让<strong>最靠近</strong>超平面的样本点的分类结果仍有较大的确信度，这就是最大化几何间隔的目的。</p>
<p>&emsp;&emsp;现在导出其数学表达，目的是求解关于参数$\boldsymbol{w},b$的超平面，使超平面到数据集中几何间隔最小的的点关于它的几何间隔最大</p>
<script type="math/tex; mode=display">
arg \underset {w,b} {max}\;\underset {i} {min} \;\gamma_i \tag{1.2-a}</script><p>若对该式直接计算，难度非常大，因为$\gamma$ 的分子和分母都包含了变量$\boldsymbol{w},b$，因此先将其等价替换为函数间隔，问题变为</p>
<script type="math/tex; mode=display">
arg  \underset {w,b} {max}\;\underset {i} {min} \;\frac {\widehat \gamma_i}{||\boldsymbol{w}||} \tag{1.2-b}</script><p>因为$||\boldsymbol{w}||$与 $i$无关，可以直接将其提出来</p>
<script type="math/tex; mode=display">
arg  \underset {w,b} {max}\;\left \{  \frac {1}{||\boldsymbol{w}||}  \underset {i} {min} \; \widehat \gamma_i  \right \} \tag{1.2-c} \\</script><p>&emsp;&emsp;为了简化计算，需要利用函数间隔的性质：函数间隔的大小随$\boldsymbol{w},b$的放缩而放缩，对于同一组$\boldsymbol{w},b$ 所有样本的函数间隔的相对间隔也是按相同比例放缩。所以我们可以用函数间隔最小的点作为基准点，将其函数间隔令为1。那么其他点的函数间隔只是按$1/\gamma$的比例进行放缩，并不影响其相对超平面的位置，也不会影响超平面的位置。</p>
<p>&emsp;&emsp;其实几何间隔就是规范化后的函数间隔，$w$作为变量，几何间隔的大小只与$w$的方向有关，与其模长无关。直接将其令为1后就不能这样写作一个式子了，数据集的函数间隔为1，那么所有样本都必须满足函数间隔大于等于1的条件。于是将其他点函数间隔大于1的<strong>约束条件</strong>单独写出来，问题变为解一个规划问题</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underset {w,b} {max} \;\; &\frac {1} {||\boldsymbol{w}||}\\
\underset i {min} \;\;&\widehat \gamma_i \geqslant 1,\;\;\; i=1,2,\cdots, n
\end{aligned}</script><p>同样为了计算方便，将最大化$||\boldsymbol{w}||^{-1}$改为等价的最小化$||\boldsymbol{w}||^2$，于是问题变为二次规划问题</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underset {w,b} {min} \;\; & \frac 1 2 {||\boldsymbol{w}||^2} \\
\underset i {min} \;\;&\widehat \gamma_i \geqslant 1,\;\;\; i=1,2,\cdots, n
\end{aligned}</script><p>&emsp;&emsp;其中$1/ 2$是为了简化计算结果。这就是SVM要解决的基本问题，下面讨论SVM如何解决这一问题，并且对于更复杂的情形如何处理。</p>
<h2 id="2-线性可分SVM"><a href="#2-线性可分SVM" class="headerlink" title="2. 线性可分SVM"></a>2. 线性可分SVM</h2><p>&emsp;&emsp;定义中导出的问题实际就是根据线性可分的情况推导的，因此我们只需要求解基本情况的二次规划问题就能得到一个线性可分的SVM模型。求解这类带约束优化问题的基本思路就是先通过拉格朗日函数转化为无约束优化问题。</p>
<script type="math/tex; mode=display">
L(w,b,\lambda) = \frac 1 2 ||\boldsymbol{w}||^2 +\sum_i^n \lambda_i -  \sum_i^n \lambda_i [y_i(\boldsymbol{\boldsymbol{w}\cdot x_i} + b) ]</script><p>注意$\boldsymbol{w},\; \boldsymbol{x_i}$是维度相同的 <strong>向量</strong> ，对于这个广义拉格朗日的最小化问题可以求偏导令为0，再利用KKT条件约束来解，但这样计算量太大。因为这个函数是凸函数，所以可以求解其对偶问题来得到原问题等价的解。关于对偶性在另一篇笔记——拉格朗日对偶性(Lagrange duality)</p>
<h3 id="2-1-对偶问题"><a href="#2-1-对偶问题" class="headerlink" title="2.1 对偶问题"></a>2.1 对偶问题</h3><p>&emsp;&emsp;首先写出原问题的极小极大形式</p>
<script type="math/tex; mode=display">
\underset {\boldsymbol{w},b}{min}\; L(\boldsymbol{w},b,\lambda) = \underset {w,b} {min}\; \underset {\lambda} {max} \;L(\boldsymbol{w},b,\lambda)</script><p>其对偶问题便是极大极小问题</p>
<script type="math/tex; mode=display">
\underset {\lambda} {max} \;\underset {w,b} {min}\; L(\boldsymbol{w},b,\lambda)</script><p>在原问题中，先求关于$\lambda$的极大，便会对$\lambda$求偏导得到一串等式，但这个结果实际上就是原来的约束条件。仍未简化问题，但若先对$\boldsymbol{w},b$先计算极小，则会得到一个较易计算的式子。这是使用对偶性的原因。</p>
<p>&emsp;&emsp;那么可以先求解内部的极小问题，对$\boldsymbol{w},b$求偏导并令为0得</p>
<script type="math/tex; mode=display">
\begin{aligned}
\triangledown _wL(\boldsymbol{w},b,\lambda) =\boldsymbol{w} - \sum_i^n \lambda_i y_i\boldsymbol{x_i}=0\\
\triangledown _bL(\boldsymbol{w},b,\lambda) =-\sum_i^n  \lambda_i y_i = 0
\end{aligned}</script><p>注意对$\boldsymbol{w}$的求导是对向量的求导，可查阅矩阵微分方面的内容。由上式得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{w} = \sum_i^n \lambda_i y_i\boldsymbol{x_i}\\
\sum_i^n  \lambda_i y_i = 0
\end{aligned}</script><p>带入原拉格朗日函数</p>
<script type="math/tex; mode=display">
\begin{aligned}
L(w,b,\lambda) =& \frac 1 2 \boldsymbol{w^Tw} +\sum_i^n \lambda_i - \sum_i^n \lambda_iy_i(\boldsymbol{\boldsymbol{w^T}\cdot x_i} + b)\\
=& \frac 1 2 \left( \sum_i^n\lambda_i y_i \boldsymbol{x_i} \right)^T \boldsymbol{\cdot} \left ( \sum_j^n \lambda_j y_j \boldsymbol{x_j} \right)+\sum_i^n \lambda_i - \sum_i^n \lambda_iy_i  \left (\left( \sum_j^n \lambda_j y_j \boldsymbol{x_j} \right)\cdot \boldsymbol{x_i}+b \right)\\
=& \frac 1 2\ \sum_i^n\lambda_i y_i \boldsymbol{x_i} ^T \boldsymbol{\cdot} \sum_j^n \lambda_j y_j \boldsymbol{x_j} +\sum_i^n \lambda_i - \sum_i^n \lambda_iy_i  \left (\left( \sum_j^n \lambda_j y_j \boldsymbol{x_j} \right)\cdot \boldsymbol{x_i}+b \right)\\
=& \frac 1 2 \sum_i^n\sum_j^n \lambda_i\lambda_jy_iy_j (\boldsymbol{x_i^T\cdot x_j})+\sum_i^n \lambda_i - \sum_i^n\sum_j^n \lambda_i\lambda_jy_iy_j (\boldsymbol{x_i^T\cdot x_j})-\sum_i^n\lambda_i y_ib\\
=&- \frac 1 2\sum_i^n\sum_j^n \lambda_i\lambda_jy_iy_j (\boldsymbol{x_i^T\cdot x_j}) + \sum_i^n \lambda_i
\end{aligned}</script><p>这个函数是对$\boldsymbol{w},b$求极小后的函数，那么现在它只与$\lambda$有关。这样我们就得到了对偶问题，对$\lambda$求极大</p>
<script type="math/tex; mode=display">
\begin{aligned}
 \underset \lambda {max} \;\; &- \frac 1 2 \sum_i^n\sum_j^n \lambda_i\lambda_jy_iy_j (\boldsymbol{x_i^T\cdot x_j}) + \sum_i^n \lambda_i\\
s.t.\;\;& \sum_i^n \lambda_i y_i = 0 \\
& \lambda_i \ge 0, \;\; i=1,\cdots,n
\end{aligned}</script><p>根据凸优化习惯，将极大化转化为极小化</p>
<script type="math/tex; mode=display">
\begin{aligned}
 \underset \lambda {min} \;\; & \frac 1 2 \sum_i^n\sum_j^n \lambda_i\lambda_jy_iy_j (\boldsymbol{x_i^T\cdot x_j}) - \sum_i^n \lambda_i\\
s.t.\;\;& \sum_i^n \lambda_i y_i = 0 \\
& \lambda_i \ge 0, \;\; i=1,\cdots,n
\end{aligned}</script><p>&emsp;&emsp;其中，只有$\lambda$是未知变量，当未知变量个数较少时，可以较轻松的算出来，比如李航书中给出一个$\lambda$数量为3的例题，可以直接将下面约束中的等式将其中一个变量带换掉，然后对两个未知变量求偏导。依据不等式约束判断是否符合，不符合则在边界取得极值，两个变量尝试边界也较简单，分别带入比较大小即可。可是该对偶问题的未知变量$\lambda$的数量与样本数成正比，机器学习中成千上万的样本量使得计算变得非常复杂，很多变量不能轻易消去，且带边界的时候有很多组合。于是下面介绍简化这个问题的优化算法——SMO。</p>
<h3 id="2-2-序列最小最优算法（SMO）"><a href="#2-2-序列最小最优算法（SMO）" class="headerlink" title="2.2 序列最小最优算法（SMO）"></a>2.2 序列最小最优算法（SMO）</h3><p>&emsp;&emsp;SMO算法由Microsoft Research的John C. Platt在1998年提出，并成为最快的二次规划优化算法，特别针对线性SVM和数据稀疏时性能更优。关于SMO最好的资料就是他本人写的《Sequential Minimal Optimization A Fast Algorithm for Training Support Vector Machines》。</p>
<h4 id="2-2-1-坐标下降法"><a href="#2-2-1-坐标下降法" class="headerlink" title="2.2.1 坐标下降法"></a>2.2.1 坐标下降法</h4><p>&emsp;&emsp;SMO算法的思想与坐标下降法十分类似，因此先介绍下坐标下降法。它是一种非梯度优化算法，梯度优化算法是每次选择梯度最大的方向进行优化，当然这使得每次优化的程度较大。不过计算量较多，尤其是变量较多的情况。而坐标下降法每次只对一个坐标方向进行优化，如此循环，对每个坐标轴依次优化。这样的做法可能会使得优化过程显得较为”曲折“，不过中间每步对单个坐标轴的计算比整个梯度的计算小得多。可以由下图表示</p>
<center>
<img src="https://i.loli.net/2019/08/27/PyvipKD32dVbUHT.png" width="600">
</center>

<p>&emsp;&emsp;坐标下降法不一定是对坐标方向进行优化，也可以自己选择一组基，对这组基的方向进行优化。不过它的优化方向仍是在一开始就决定了。SMO也是这种思想，在SVM的对偶问题中，其对偶变量为$\boldsymbol{\lambda}$，而$\boldsymbol{\lambda}$的数量与样本的数量成正比。对如此多的变量同时优化无疑是比较困难的，因此借鉴坐标下降法，对其中一部分变量进行优化，不断循环的对所有变量依次优化，这样迭代可以得到一个期望的优化结果。</p>
<p>&emsp;&emsp;对于SVM的对偶问题</p>
<script type="math/tex; mode=display">
\begin{aligned}
 \underset \lambda {min} \;\; & \frac 1 2 \sum_i^n\sum_j^n \lambda_i\lambda_jy_iy_j (\boldsymbol{x_i^T\cdot x_j}) - \sum_i^n \lambda_i\\
s.t.\;\;& \sum_i^n \lambda_i y_i = 0 \\
& \lambda_i \ge 0, \;\; i=1,\cdots,n
\end{aligned}</script><p>由于$\boldsymbol\lambda$数量等于样本$(\boldsymbol{x_i},y_i)$数量，使得这个二次规划问题计算量较大，因此选择其中两个作为变量，其他看做常数，对这两个变量解二次规划问题，并且这时两个变量也满足约束$\sum_i^n \lambda_i y_i = 0$ ，所以这个问题有解析解，求解速度非常快。</p>
<p><strong>Q:</strong>为什么选两个变量呢？</p>
<p>&emsp;&emsp;同样是因为约束条件$\sum_i^n \lambda_i y_i = 0$ ，$\lambda_i$在更新后需要满足它们之间的等式，所以需要同时更新两个变量。</p>
<h4 id="2-2-2-SMO求解方法"><a href="#2-2-2-SMO求解方法" class="headerlink" title="2.2.2 SMO求解方法"></a>2.2.2 SMO求解方法</h4><p>&emsp;&emsp;不失一般性，假设选择的两个变量为$\lambda_1,\lambda_2$ ，其他变量看作常数，则原二次规划问题变为</p>
<script type="math/tex; mode=display">
\begin{aligned}
 \underset {\lambda_1,\lambda_2} {min} \;\;\;\;\;\;\;\; & W(\lambda_1,\lambda_2)=\frac 1 2 \lambda_1^2(x_1^Tx_1)+\frac 1 2 \lambda_2^2(x_2^Tx_2) + \lambda_1\lambda_2y_1y_2(x_1^Tx_2) + \\
 &\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;   \lambda_1y_1\sum_{i=3}^n\lambda_iy_i(x_1^Tx_i) + \lambda_2y_2\sum_{i=3}^n\lambda_iy_i(x_2^Tx_i) -(\lambda_1+\lambda_2)+ Constant       \\
s.t.\;\;\;\;\;\;\;\;\;& \lambda_1y_1+\lambda_2y_2=-\sum_{i=3}^n\lambda_iy_i= \zeta \\
& \lambda_i \ge 0, \;\; i=1,2
\end{aligned}</script><p>对这两个变量的优化中，其中的等式约束给出了它们之间的关系。那么可用其中一个表示另一个变为一个变量的优化，这里用$\lambda_1$表示$\lambda_2$，且目标函数中的常数项不需要再考虑</p>
<script type="math/tex; mode=display">
\lambda_1 =y_1\zeta - \lambda_2 y_1y_2  \tag{2.2.2-1}</script><p> &emsp;&emsp;通过等式约束得到两个变量之间的关系后，将其带入原优化表达式，便能够对单变量进行优化，这当然是我们希望看到的情况，不过除了等式约束还有不等式约束。好在只有两个变量，我们可以先计算出单变量迭代的结果，再考察是否满足不等式约束，对结果进行修剪。</p>
<h5 id="2-2-2-1-求解等式约束"><a href="#2-2-2-1-求解等式约束" class="headerlink" title="2.2.2.1 求解等式约束"></a>2.2.2.1 求解等式约束</h5><p> &emsp; &emsp;简化表达，记</p>
<script type="math/tex; mode=display">
v_i = \sum_{j=3}^n \lambda_jy_j(x_i^Tx_j)</script><p>则目标函数可写作</p>
<script type="math/tex; mode=display">
\begin{aligned}
W(\lambda_1,\lambda_2)=& \frac 1 2 \lambda_1^2(x_1^Tx_1)+\frac 1 2 \lambda_2^2(x_2^Tx_2) + \lambda_1\lambda_2y_1y_2(x_1^Tx_2) + \\
&\;\;\;\;\;  \lambda_1y_1v_1 + \lambda_2y_2v_2 -(\lambda_1+\lambda_2)   \\
\end{aligned} \tag{2.2.2.1-1}</script><p>将$(2.2.1-1)$代入得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
W(\lambda_2)=& \frac 1 2 (\zeta - \lambda_2 y_2)^2(x_1^Tx_1)+\frac 1 2 \lambda_2^2(x_2^Tx_2) + (\zeta - \lambda_2 y_2)\lambda_2y_2(x_1^Tx_2) + \\
 &\;\;\;\;\;  (\zeta - \lambda_2 y_2)v_1 + \lambda_2y_2v_2 -y_1(\zeta - \lambda_2 y_2)-\lambda_2   \\
\end{aligned} \tag{2.2.2.1-1}</script><p>对$\lambda_2$求偏导，</p>
<script type="math/tex; mode=display">
\frac {\partial W} {\partial \lambda_2} = \lambda_2 (x_1^Tx_1) - \zeta y_2(x_1^Tx_1) + \lambda_2(x_2^Tx_2)
-2\lambda_2 (x_1^Tx_2) + \zeta y_2 (x_1^Tx_2) \\
  -y_2 v_1 + y_2 v_2 + y_1y_2 - 1</script><p>令为0</p>
<script type="math/tex; mode=display">
\begin{aligned}
(x_1^Tx_1+x_2^Tx_2-2x_1^Tx_2)\lambda_2 =& \zeta\; y_2[\;(x_1^Tx_1)-(x_1^Tx_2)] + y_2(v_1-v_2)+y_2(y_2-y_1)\\
 =& y_2\;[ \zeta (x_1^Tx_1-x_1^Tx_2) + (v_1-v_2)+(y_2-y_1) ]
\end{aligned}\tag{2.2.2.1-2}</script><p>将$\zeta = y_1\lambda_1^{old} +y_2\lambda_2^{old}$与$v_1,v_2$代入得到右边</p>
<script type="math/tex; mode=display">
\begin{aligned}
&y_2 \left [ (y_1\lambda_1^{old}+y_2\lambda_2^{old})(x_1^Tx_1-x_1^Tx_2)  +\left ( \sum_{j=3}^n\lambda_j^{old}y_j(x_1^Tx_j) \right)- \left (  \sum_{j=3}^n\lambda_j^{old}y_j(x_2^Tx_j)  \right)  +y_2 - y_1  \right]\\
=& y_2 \left [ y_2\lambda_2^{old}(x_1^Tx_1+x_2^Tx_2-2x_1^Tx_2)+ \left ( \sum_{j=1}^n\lambda_j^{old}y_j(x_1^Tx_j) \right)- \left (  \sum_{j=1}^n\lambda_j^{old}y_j(x_2^Tx_j)  \right) +y_2-y_1 \right]\\
\end{aligned}</script><p>上式将后面求和缺少的前两项补上了，这样前面凑出来的部分正好和$2.2.2.1-2$的左端系数相同，再看后面部分的求和$\sum_{j=1}^n\lambda_j^{old}y_j(x_1^Tx_j)$ ，若加上偏置$b$，则表示的正是输入数据$x_1$到超平面的函数间隔，后面还有个$y_1$，表示$x_1$的正确类别，这似乎是故意凑好的，它们之差就是对$x_i$的预测值和它的真实值的差。且SVM中的函数间隔是以支持向量的1作为标准，与$y$的取值$\{-1,1\}$可以说是一个标准下的比较。对上式稍作调整</p>
<script type="math/tex; mode=display">
\begin{aligned}
& y_2 \left [ y_2\lambda_2^{old}(x_1^Tx_1+x_2^Tx_2-2x_1^Tx_2)+ \left ( \sum_{j=1}^n\lambda_j^{old}y_j(x_1^Tx_j) \right)- \left (  \sum_{j=1}^n\lambda_j^{old}y_j(x_2^Tx_j)  \right) +y_2-y_1 \right]\\
=&\lambda_2^{old}(x_1^Tx_1+x_2^Tx_2-2x_1^Tx_2) + y_2\left [\left ( \sum_{j=1}^n\lambda_j^{old}y_j(x_1^Tx_j) -b\right)-y_1 \right] - y_2\left [  \left (  \sum_{j=1}^n\lambda_j^{old}y_j(x_2^Tx_j) -b \right) -y_2 \right]
\end{aligned}</script><p>为表述方便，令对$x$的预测值为函数$g(x)$，其实这就是SVM的分类函数</p>
<script type="math/tex; mode=display">
g(x) =  \sum_{i=1}^n\lambda_iy_i(x^Tx_i) -b</script><p>令预测值与真实值之差为$E$</p>
<script type="math/tex; mode=display">
E_i = g(x_i) -y_i</script><p>将右端结果带回式$(2.2.2.1-2)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
(x_1^Tx_1+x_2^Tx_2-2x_1^Tx_2)\lambda_2 =& \lambda_2^{old}(x_1^Tx_1+x_2^Tx_2-2x_1^Tx_2) + y_2(E_1-E_2)
\end{aligned}</script><p>令$\eta=(x_1^Tx_1+x_2^Tx_2-2x_1^Tx_2)$,带入得到未修剪的$\lambda_2^{new,unc}$</p>
<script type="math/tex; mode=display">
\lambda_2^{new,unc} = \lambda_2^{old} + \frac {y_2(E_1-E_2)}{\eta}</script><h5 id="2-2-2-2-不等式约束修剪"><a href="#2-2-2-2-不等式约束修剪" class="headerlink" title="2.2.2.2 不等式约束修剪"></a>2.2.2.2 不等式约束修剪</h5><p>&emsp;&emsp; 上面求解了优化问题在等式约束下的解，对于这两个变量来说，等式约束实际上把他们约束在一条平面直线上，而$\lambda \ge 0$便将它们约束到<strong>第一象限</strong>。其且它们的系数不是-1就是1，这意味着它们组成的直线只有两个方向，$45^o或135^o$ 。这样就能通过作图来确定它们的上下界，且通过关系式的直线，只需确定$\lambda_2$的范围即可。这里只有下界限制，后面软间隔需要添加合页损失函数，那时会有上界，不过处理方法都相同，先看这里的情况，注意变量只有$\lambda_2$</p>
<center class="half">
<img src="https://i.loli.net/2019/08/14/MLGToeqSHXImVQC.png" width="1000">
</center>

<p>&emsp;&emsp;如图，当$y_1 \ne y_2$时，约束区域是图中的实心线，$\lambda_2$的下界与直线在$\lambda_2$轴上的截距有关，且$\lambda_2$上的截距可表示为</p>
<script type="math/tex; mode=display">
\lambda_2 - \lambda_1 = b</script><p>当截距$b&gt;0$，即绿线情况时，才会取这个截距为下界，不然就取0，即</p>
<script type="math/tex; mode=display">
L = max(0,b)</script><p>&emsp;&emsp;当$y_1 = y_2$时，其下界只需满足$\lambda_2 \ge 0$即可，不过这种情况为它带来了上界，图中很清楚，若$\lambda_2$的数值超过其在$\lambda_2$轴上的截距$b=\lambda_1+\lambda_2$，则$\lambda_1$会小于0，因此</p>
<script type="math/tex; mode=display">
L = 0 ,\\
H = b</script><p>综上</p>
<script type="math/tex; mode=display">
\begin{cases}
max(0,\lambda_2^{old} - \lambda_1^{old})\le \lambda_2^{new}   , \;\; &y_1 \ne y_2\\
0 \le  \lambda_2^{new} \le  \lambda_1^{old} + \lambda_2^{old}, &y_1=y_2
\end{cases}</script><p>&emsp;&emsp;这是不等式约束$\lambda \ge 0$带来的下界，将得到的未修剪$\lambda_2^{new,unc}$与之比较，若满足上述约束，则$\lambda_2^{new} = \lambda_2^{new,unc}$ ，若不满足约束，则取下界值即可。  这种情况较简单，在下一节解决软间隔SVM的时候，加入合页损失函数，不等式约束变为$0 \le \lambda \le C$ ，则变量不止有下界，还有上界了。不过仍可用相同的分析方法。</p>
<center class="half">
<img src="https://i.loli.net/2019/08/14/h8HJUOzANEdFcDe.png" width="1100">
</center>

<p>&emsp;&emsp;这是添加了合页损失函数后的约束空间，用截距的方法也比较容易分析，图中绿色的线会确定一个$\lambda_2$的下界，红色的线会确定一个上界，注意仍考虑$\lambda_2$的范围。</p>
<p>&emsp;&emsp;当$y_1 \ne y_2$时，截距大于0的绿线会确定一个下界，截距小于0的红线会确定一个上界</p>
<script type="math/tex; mode=display">
L = max(0, \lambda_2^{old} - \lambda_1^{old}) ,\\
H = min(C, \lambda_2^{old} - \lambda_1^{old} +C )</script><p>&emsp;&emsp;当$y_1 = y_2$时， 截距大于C的绿线会确定一个下界，截距小于C的红线会确定一个上界</p>
<script type="math/tex; mode=display">
L = max(0,\lambda_1^{old}+ \lambda_2^{old} - C),\\
H = min(C,\lambda_1^{old} + \lambda_2^{old} )</script><p>得到其不等式约束后，便可对前面求得的未修剪的$\lambda_2^{new,unc}$ 进行修剪，修剪后的数据代入SMO优化问题继续迭代，直到达到迭代误差要求。</p>
<h5 id="2-2-2-3-变量的选择方法"><a href="#2-2-2-3-变量的选择方法" class="headerlink" title="2.2.2.3 变量的选择方法"></a>2.2.2.3 变量的选择方法</h5><p>&emsp;&emsp;在二次规划问题中，最后优化得到的解一定是满足KKT条件的。换句话说，只要变量不满足KKT条件，迭代过程就会继续。因此在变量的选择中，只要选择了一个不满足KKT条件的变量，那么迭代过程就会得到增益。而对第二个变量的选择，可采用启发式方法，选择让两个变量对应的样本之间间隔最大的变量。因为相较与对两个相似的变量相比，两个差别很大的变量更新可能会给优化函数带来较大增益。</p>
<p>&emsp;&emsp;最终，我们得到了分离超平面</p>
<script type="math/tex; mode=display">
\sum_i^n \lambda_i^* y_i (x^Tx_i)+ b^{\ast} = 0</script><p>分类决策函数</p>
<script type="math/tex; mode=display">
f(x) = sign\left ( \sum_i^n \lambda_i^{\ast} y_i (x^Tx_i) + b^{\ast}  \right)</script><p>上式意味着，分类决策函数只依赖于输入样本的$x$和训练样本的$x$之间的内积。这是后面引入核方法进行非线性推广的基础。同时，决策函数中的内积只需要计算输入向量和样本求出的支持向量之间的即可。因为其他非支持向量的系数$\lambda$为0，支持向量机便是这样一个由少数支持向量决定的分类模型。</p>
<h2 id="3-线性不可分SVM"><a href="#3-线性不可分SVM" class="headerlink" title="3. 线性不可分SVM"></a>3. 线性不可分SVM</h2><p>&emsp;&emsp;前述算法是针对数据线性可分的情况，在数据不可分的情况该算法无法收敛。不过在明白了线性可分SVM的基础原理后，将其推广至线性不可分的SVM其实并不难。</p>
<h3 id="3-1-松弛变量"><a href="#3-1-松弛变量" class="headerlink" title="3.1 松弛变量"></a>3.1 松弛变量</h3><p>&emsp;&emsp;若一组数据整体线性可分，只是有一些奇异点干扰。如下图</p>
<center class="half">
<img src="https://i.loli.net/2019/08/14/Rjc2Nl3XLP1AwDo.jpg" width="700">
</center>

<p>这些少量的奇异点使得不能找到一个超平面将所有数据正确划分，然而数据整体又是可分的，为了继续使用线性SVM，我们需要对这些奇异点添加一个松弛变量$\xi$。也就是对它们的错误进行一定程度的容忍，也就是使得这些奇异点的函数间隔加上松弛变量后能够满足大于等于1 的约束。</p>
<script type="math/tex; mode=display">
\widehat \gamma = y_i(w\cdot x_i + b ) + \xi_i \ge 1</script><p>既然对约束条件进行了弱化，那么就需要在目标优化函数$\frac 1 2 ||w||^2$中付出一定的代价</p>
<script type="math/tex; mode=display">
\frac 1 2 ||w||^2 + C \sum_i^n \xi _i</script><p>其中，$\xi \ge 0$</p>
<p>&emsp;&emsp;由此得到新的SVM优化问题</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underset {w,b,\xi} {min} \;\;\; & \frac 1 2 ||w||^2 + C \sum_i^n \xi _i\\
s.t. \;\;\; & y_i(w\cdot x_i + b) + \xi_i \ge 1\\
& \xi_i \ge 0
\end{aligned}</script><p>得到软间隔下的优化问题后，步骤就与线性可分SVM相同了，先找到对偶问题，再用SMO算法求解即可。</p>
<h3 id="3-2-求解对偶问题"><a href="#3-2-求解对偶问题" class="headerlink" title="3.2 求解对偶问题"></a>3.2 求解对偶问题</h3><p>&emsp;&emsp;找对偶问题也是按流程来就行了，先列出拉格朗日函数，转化为极大极小问题，求解关于$w,b,\xi$的极小问题，再对得到的极小函数求解关于$\lambda,\eta$ 的极大问题，也就是对偶问题。</p>
<ul>
<li>原始问题的拉格朗日函数</li>
</ul>
<script type="math/tex; mode=display">
L(w,b,\xi,\lambda,\eta) = \frac 1 2 ||w||^2 + C\sum_i^n\xi_i - \sum_i^n\lambda_i[y_i(w\cdot x_i+b)+\xi_i -1] - \sum_i^n \eta_i \xi_i \tag{3.1}</script><p>其中，$\lambda_i\ge 0,\eta \ge 0$。</p>
<p>&emsp;&emsp;转化为极大极小问题，先求解关于$w,b,\xi$ 的极小问题，对拉格朗日函数求关于$w,b,\xi$的偏导并令为0</p>
<script type="math/tex; mode=display">
\triangledown_ w L(w,b,\xi,\lambda,\eta)=w - \sum_i^n \lambda_i y_i x_i = 0\\
\triangledown _b L(w,b,\xi,\lambda,\eta) = -\sum_i^n \lambda_iy_i = 0\\
\triangledown _\xi L(w,b,\xi,\lambda,\eta) = C - \lambda_i - \eta_i = 0</script><p>得到</p>
<script type="math/tex; mode=display">
\begin{eqnarray*}
\sum_i^n\lambda_i y_i x_i &=&  w   \tag{3.2}  \\ 
\sum_i^n\lambda_i y_i &=& 0       \tag{3.3}  \\
C - \lambda_i - \eta_i &=& 0  \tag{3.4}
\end{eqnarray*}</script><p>将它们带回式$(3.1)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underset {w,b,\xi} {min} \;\;L(w,b,\xi,\lambda,\eta) =& \frac 1 2\left ( \sum_i^n\lambda_iy_ix_i \right)\left ( \sum_j^n\lambda_jy_jx_j \right) +(C -\lambda_i-\eta_i)\sum_i^n \xi_i -\\
& \;\;\;\;\;\; \sum_i^n \lambda_iy_i\sum_j^n\lambda_jy_jx_j^Tx_i-\sum_i^n \lambda_iy_ib+\sum_i^n\lambda_i\\
=& -\frac 1 2 \sum_i^n\sum_j^n\lambda_i\lambda_jy_iy_j(x_i^Tx_j) + \sum_i^n\lambda_i 
\end{aligned}</script><p>再对其求关于$\lambda,\eta$ 的极大即得到对偶问题</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underset {\lambda,\eta}{max} \;\; &-\frac 1 2\sum_i^n\sum_j^n\lambda_i\lambda_jy_iy_j(x_i^Tx_j) + \sum_i^T\lambda_i\\
s.t.\;\; & \sum_i^n \lambda_iy_i = 0\\
&C-\lambda_i-\eta_i = 0\\
&\lambda_i \ge 0 , \;\; i=1,\cdots,n\\
&\eta _i \ge 0 ,\;\; i=1,\cdots,n
\end{aligned}</script><p>注意被优化函数中并没有$\eta$，和有关于它的等式，将$\eta_i = C-\lambda_i$带入$\eta_i\ge 0$</p>
<script type="math/tex; mode=display">
C \ge \lambda_i</script><p>整理得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underset {\lambda}{max} \;\; &-\frac 1 2\sum_i^n\sum_j^n\lambda_i\lambda_jy_iy_j(x_i^Tx_j) + \sum_i^T\lambda_i\\
s.t.\;\; & \sum_i^n \lambda_iy_i = 0\\
& 0\le \lambda_i \le C ,\;\;\;i=1,\cdots,n
\end{aligned}</script><p>&emsp;&emsp;相较与线性可分下的SVM，软间隔SVM的对偶问题在形式上只比线性可分情况下的对偶问题多一个$\lambda_i$ 的上界约束C，对于求解过程中的差异主要表现在SMO算法的修剪过程中，需要确定的约束范围变小了。而这一变化在上节线性 可分SVM的SMO中已经给出了，后面的SMO过程可以说与线性可分SVM完全相同了。这样就得到一个可以容忍噪声奇异点干扰的SVM线性分类器了。</p>
<h3 id="3-3-支持向量求解参数-w-b"><a href="#3-3-支持向量求解参数-w-b" class="headerlink" title="3.3 支持向量求解参数$w,b$"></a>3.3 支持向量求解参数$w,b$</h3><p>&emsp;&emsp;求解出对偶问题的参数$\lambda$ 后，还需考虑一个问题，就是如何通过这个参数$\lambda$和训练数据$\{x,y\}$得到我们需要的参数$w,b$ 。因为原始问题是凸二次规划问题，可以通过KKT条件来从 <strong>原始问题</strong> 中找出$w,b$ 与$\lambda,x,y$ 之间的关系。</p>
<p>&emsp;&emsp;根据KKT条件中的梯度为0条件，可以很容易的得出$w$的表达式</p>
<script type="math/tex; mode=display">
\triangledown_wL(w^*,b^*,\xi^*,\lambda^*,\eta^*) = w^* - \sum_i^n\lambda_i^*y_ix_i = 0</script><p>得到</p>
<script type="math/tex; mode=display">
w^* = \sum_i^n \lambda_i^* y_i x_i</script><p>&emsp;&emsp;对于$b$，并没有一个直接的等式让我们求出其表达式。唯一一个等式是由松弛互补性得到的</p>
<script type="math/tex; mode=display">
\lambda_i ( y_i(w^*\cdot x + b^*) + \xi_i^*-1) = 0  \tag{3.5}</script><p>如果$\lambda_i &gt; 0$的话，那么就能得到一个关于$b$的等式</p>
<script type="math/tex; mode=display">
\begin{aligned}
b^* =& (1-\xi_i^*)y_i -w^*\cdot x\\
=&(1-\xi_i^*)y_i - \sum_j^n\lambda_j^*y_j(x_i^Tx_j)
\end{aligned} \tag{3.6}</script><p>其中，$\xi_i^{\ast}$比较讨厌，但是在一定条件下可以利用KKT中其他约束将其消去</p>
<script type="math/tex; mode=display">
\begin{eqnarray*}
\triangledown_\xi L(w^*,b^*,\xi^*,\lambda^*,\eta^*) = C-\lambda_i-\eta_i = 0  \tag{3.7}  \\
\eta_i \xi_i = 0  \tag{3.8}
\end{eqnarray*}</script><p>由$(3.7)与(3.8)$可以得到，当$0&lt;\lambda_i &lt; C$ 时，$\eta_i &gt; 0$，$\xi_i = 0$，此时</p>
<script type="math/tex; mode=display">
b = y_i -\sum_j^n\lambda_j^*y_j (x_i^Tx_j)</script><p>当$\lambda_i = C$ 时，则$\xi_i$不一定等于0了，而是很有可能大于0，此时若用$\lambda_i$ 进行计算就得使用$(3.6)$的形式，因此在参数$b$的计算中，最好的情况是找一个$0&lt;\lambda_i &lt; C$的点进行计算。</p>
<center class="half">
<img src="https://i.loli.net/2019/08/14/Rjc2Nl3XLP1AwDo.jpg" width="700">
</center>

<p>&emsp;&emsp;事实上，如图，当$0&lt;\lambda_i&lt; C$时，样本$x_i$ 便是支持向量，其代价$\xi_i = 0$ ，正好在间隔边界上。当$\lambda_i = 0$时，该向量不是支持向量，位于正确分割的间隔边界外。当$ \lambda_i = C,\;\xi_i<1$ 时，此时$x_i$也是支持向量，被正确分割，位于超平面和正确分割边界之间。当$\lambda_i="C," \; \xi_i="1$" 时，$x_i$是支持向量，位于超平面上。当$\lambda_i="C,\;"> 1$ 时，$x_i$是支持向量，位于误分类一侧。</1$></p>
<p>&emsp;&emsp;所以，$b$ 的计算最好选择恰在间隔边界上的支持向量。</p>
<h2 id="4-非线性SVM"><a href="#4-非线性SVM" class="headerlink" title="4. 非线性SVM"></a>4. 非线性SVM</h2><p>&emsp;&emsp;在线性SVM中，我们求解的目标都是一个线性的分离超平面</p>
<script type="math/tex; mode=display">
w^T\cdot x + b = 0</script><p>只要参数$w，b$ 得到了，那对于新的输入向量$x$ ，其不同分量与$w$分量的线性组合（也就是内积）加上$b$ 便决定了分类结果。显然以此定义的模型只能训练出线性分类模型。</p>
<p>&emsp;&emsp;若要实现对非线性模型的分类，我们需要得到一些关于$x$ 分量的一些非线性组合。$w$是$x$的系数，那只能从$x$入手了。如果将$x$的不同分量映射到一个更高维的空间，这些映射后的分量的线性组合也能实现$x$ 原分量的非线性组合。比如</p>
<script type="math/tex; mode=display">
x = \begin{bmatrix}
x_1\\ 
x_2
\end{bmatrix}\;\;\; \Rightarrow \;\;\;
\Phi = \begin{bmatrix}
x_1^2\\ 
x_1x_2\\
x_2^2
\end{bmatrix}</script><p>其中，$x$的维度是2，说明这应该是一个在二维平面中分类的模型，$\Phi$ 是$x$ 的一个映射，映射后的数据变为了三维的，但是其训练后关于这三个变量的线性组合中变量仍只有$x_1,x_2$ ，不过通过对它训练，我们可以得到一个关于$x_1,x_2$的非线性模型，比如训练得到的参数 $w=[1,0,1]^T$  ，那实际上得到的是一个关于$x_1,x_2$ 的一个圆。</p>
<p>&emsp;&emsp;这种方法将原始数据映射到新的高维空间，也叫特征空间（希尔伯特空间）。关于希尔伯特空间可参考<a href="http://open.163.com/movie/2013/3/T/0/M8PTB0GHI_M8PTBUHT0.html" target="_blank" rel="noopener">上海交通大学公开课</a> ，希尔伯特空间可大致理解为有限的欧几里得内积空间添加了完备性后的空间。这里有一篇对这个公开课较好的<a href="https://blog.csdn.net/weixin_36811328/article/details/81207753" target="_blank" rel="noopener">总结</a> 。由泰勒展开公式可知，一个函数展开到的阶数越高，就越能拟合复杂的曲线。上面的例子中阶数仅仅提升到2，若有较复杂的分割模型，它仍不能较好的完成任务。但是若将其提升到很高的维度，甚至是无穷大维，计算量是非常大甚至是难以计算的。因为既要计算$x$到$\Phi$的映射，还要计算高维$\Phi$与系数的乘积后的求和。</p>
<p>&emsp;&emsp;现在似乎找到了解决非线性问题的一个方法，但是计算量太大了，幸运的是，在SVM的对偶问题中，目标函数与求解得到的分类决策函数都是输入向量之间的内积</p>
<script type="math/tex; mode=display">
W(\lambda) = \frac 1 2 \sum_i^n\sum_j^n \lambda_i\lambda_jy_iy_j (x_i^Tx_j) - \sum_i^n \lambda_i</script><p>输入向量使用相同的映射到高维空间，并且是内积的形式，那么这种情况可以使用<strong>核方法</strong>来减少计算量。核方法可以跳过求解$x$到$\Phi$的映射和计算映射后的函数的内积的过程。</p>
<p>&emsp;&emsp;它的主要依据是，先定义一个关于原输入向量内积的核函数，总可以将其拆解为输入向量的映射之间的内积的形式。比如一个简单的 平方核函数</p>
<script type="math/tex; mode=display">
K(x,z) = (x\cdot z)^2</script><p>它是关于输入向量的内积的平方函数，可以通过将输入向量映射到</p>
<script type="math/tex; mode=display">
\Phi(x) = (x_1^2,\sqrt2 x_1x_2,x_2^2)^T</script><p>可以验证</p>
<script type="math/tex; mode=display">
\Phi(x) \cdot \Phi(z) = (x\cdot z)^2 = K(x,z)</script><p>当然拆解的映射函数不止这一种，这说明当需要将一个向量映射到高维空间并且作内积时，为了减少计算量，可以不用管映射函数，而只是计算核函数的值便等价与计算映射后的函数的内积。</p>
<p>&emsp;&emsp;核函数肯定不是随便定义一个都行的，它需要满足正定核条件，正定核的充要条件是该核函数的Gram矩阵是半正定的。</p>
<h2 id="5-Reference"><a href="#5-Reference" class="headerlink" title="5. Reference:"></a>5. Reference:</h2><p>[1]  <a href="https://web.stanford.edu/~boyd/cvxbook/" target="_blank" rel="noopener">Convex Optimization</a></p>
<p>[2] Pattern Recognition and Machine Learning.</p>
<p>[3] 统计学习方法</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="../../../../../../tags/机器学习/" rel="tag"># 机器学习</a>
          
            <a href="../../../../../../tags/SVM/" rel="tag"># SVM</a>
          
            <a href="../../../../../../tags/SMO/" rel="tag"># SMO</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="../../../../20/enviroment/海思3559a移植/" rel="next" title="海思3559A系统移植">
                <i class="fa fa-chevron-left"></i> 海思3559A系统移植
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="../../../../22/ML/CRF/条件随机场/" rel="prev" title="条件随机场">
                条件随机场 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">brezezee</p>
              <p class="site-description motion-element" itemprop="description">靡不有初，鲜克有终</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="https://brezezee.github.io/archives">
              
                  <span class="site-state-item-count">122</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="../../../../../../categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="../../../../../../tags/index.html">
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-定义"><span class="nav-text">1. 定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-函数间隔和几何间隔"><span class="nav-text">1.1 函数间隔和几何间隔</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-间隔最大化"><span class="nav-text">1.2 间隔最大化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-线性可分SVM"><span class="nav-text">2. 线性可分SVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-对偶问题"><span class="nav-text">2.1 对偶问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-序列最小最优算法（SMO）"><span class="nav-text">2.2 序列最小最优算法（SMO）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-坐标下降法"><span class="nav-text">2.2.1 坐标下降法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-SMO求解方法"><span class="nav-text">2.2.2 SMO求解方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-1-求解等式约束"><span class="nav-text">2.2.2.1 求解等式约束</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-2-不等式约束修剪"><span class="nav-text">2.2.2.2 不等式约束修剪</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-3-变量的选择方法"><span class="nav-text">2.2.2.3 变量的选择方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-线性不可分SVM"><span class="nav-text">3. 线性不可分SVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-松弛变量"><span class="nav-text">3.1 松弛变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-求解对偶问题"><span class="nav-text">3.2 求解对偶问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-支持向量求解参数-w-b"><span class="nav-text">3.3 支持向量求解参数$w,b$</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-非线性SVM"><span class="nav-text">4. 非线性SVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Reference"><span class="nav-text">5. Reference:</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">brezezee</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">162k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="../../../../../../lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="../../../../../../lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="../../../../../../lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="../../../../../../lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../../../../../lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../../../../../lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="../../../../../../js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="../../../../../../js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="../../../../../../js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="../../../../../../js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="../../../../../../js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://brezezee.github.io/2019/08/21/ML/SVM/SVM/';
          this.page.identifier = '2019/08/21/ML/SVM/SVM/';
          this.page.title = 'SVM推导';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
